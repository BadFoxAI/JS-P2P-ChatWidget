<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat Component - ServerOne Logic</title>
    <style>
        /* --- Theme Variables --- */
        :root {
            /* Default: Dark Theme */
            --chat-bg-body: #1a1a1a;
            --chat-bg-container: #2d2d2d;
            --chat-bg-input: #3c3c3c;
            --chat-bg-chat: #252525;
            --chat-bg-status: #333333;
            --chat-bg-button-primary: #007acc;
            --chat-bg-button-primary-hover: #005fa3;
            --chat-bg-button-secondary: #505050;
            --chat-bg-button-secondary-hover: #606060;
            --chat-bg-button-disabled: #404040;
            --chat-text-primary: #e0e0e0;
            --chat-text-secondary: #b0b0b0;
            --chat-text-input: #f0f0f0;
            --chat-text-button: #ffffff;
            --chat-text-button-secondary: #e0e0e0;
            --chat-text-system: #9e9e9e;
            --chat-border-color: #4a4a4a;
            --chat-msg-bg-local: #004d7a;
            --chat-msg-bg-remote: #3e4042;
            --chat-icon-color: #b0b0b0;
            --chat-icon-hover-color: #ffffff;
            --chat-box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            --chat-modal-bg: rgba(0, 0, 0, 0.6);
            --chat-modal-content-bg: var(--chat-bg-container);
        }

        body.chat-light-theme { /* Light Theme Overrides */
            --chat-bg-body: #f4f6f8;
            --chat-bg-container: #ffffff;
            --chat-bg-input: #f9f9f9;
            --chat-bg-chat: #f5f5f5;
            --chat-bg-status: #eeeeee;
            --chat-bg-button-primary: #007bff;
            --chat-bg-button-primary-hover: #0056b3;
            --chat-bg-button-secondary: #6c757d;
            --chat-bg-button-secondary-hover: #545b62;
            --chat-bg-button-disabled: #cccccc;
            --chat-text-primary: #212529;
            --chat-text-secondary: #495057;
            --chat-text-input: #333333;
            --chat-text-button: #ffffff;
            --chat-text-button-secondary: #ffffff;
            --chat-text-system: #6c757d;
            --chat-border-color: #ced4da;
            --chat-msg-bg-local: #007bff;
            --chat-msg-bg-remote: #e9ecef;
            --chat-icon-color: #495057;
            --chat-icon-hover-color: #000000;
            --chat-box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            --chat-modal-bg: rgba(0, 0, 0, 0.4);
            --chat-modal-content-bg: var(--chat-bg-container);
        }

        /* --- General Body Style --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--chat-bg-body);
            color: var(--chat-text-primary);
            margin: 0; padding: 0; font-size: 15px; line-height: 1.6;
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        /* --- Chat Module Styles --- */
        #chatModuleWrapper { position: fixed; bottom: 20px; right: 20px; z-index: 1000; }
        #chatModuleContainer {
            width: 380px; max-height: calc(100vh - 90px); display: flex; flex-direction: column;
            background-color: var(--chat-bg-container); color: var(--chat-text-primary);
            border-radius: 10px; box-shadow: var(--chat-box-shadow);
            border: 1px solid var(--chat-border-color); overflow: hidden;
            transition: width 0.25s ease-out, height 0.25s ease-out, opacity 0.25s ease-out, transform 0.25s ease-out;
            transform-origin: bottom right;
        }
        #chatModuleContainer.collapsed {
            width: 48px; height: 48px; padding: 0; overflow: visible;
            border: none;
            background-color: transparent; box-shadow: none;
        }
        #chatModuleContainer.collapsed > *:not(#moduleToggleBar) { display: none !important; }

        #moduleToggleBar {
            display: flex; justify-content: space-between;
            align-items: center; padding: 6px 10px; background-color: var(--chat-bg-status);
            border-bottom: 1px solid var(--chat-border-color); user-select: none;
        }
        #chatModuleContainer.collapsed #moduleToggleBar {
            padding: 0; background-color: var(--chat-bg-button-secondary);
            width: 48px; height: 48px; border-radius: 50%;
            justify-content: center; align-items: center;
            border-bottom: none; box-shadow: var(--chat-box-shadow);
            cursor: pointer;
        }
        #chatModuleContainer.collapsed #moduleToggleBar #chatModuleTitle,
        #chatModuleContainer.collapsed #moduleToggleBar #themeToggleIcon,
        #chatModuleContainer.collapsed #moduleToggleBar #clearStorageIcon {
             display: none !important;
        }
        #chatModuleContainer.collapsed #moduleToggleBar #collapseIcon {
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-size: 22px;
            line-height: 1;
            border-radius: 0;
        }
        #chatModuleTitle { font-weight: 500; font-size: 1.05em; }
        .toggle-icon-group { display: flex; align-items: center; }
        #chatModuleContainer.collapsed #moduleToggleBar .toggle-icon-group {
            width: 100%;
            height: 100%;
            justify-content: center;
        }
        .toggle-icon {
            cursor: pointer; font-size: 20px;
            padding: 5px; margin-left: 6px; line-height: 1;
            color: var(--chat-icon-color); transition: color 0.2s ease, transform 0.15s ease;
            display: inline-flex; align-items: center; justify-content: center; border-radius: 4px;
        }
        .toggle-icon:hover { color: var(--chat-icon-hover-color); background-color: rgba(120,120,120,0.15);}
        .toggle-icon:active { transform: scale(0.9); }

        #chatModuleContent { padding: 15px; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

        .name-control-group { display: flex; gap: 8px; margin-bottom: 15px; align-items: center; }
        #displayNameInput {
            flex-grow: 1; padding: 9px 12px; background-color: var(--chat-bg-input);
            color: var(--chat-text-input); border: 1px solid var(--chat-border-color);
            border-radius: 6px; font-size: 14px;
        }
        #displayNameInput::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}
        #setDisplayNameBtn {
             padding: 9px 12px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; transition: background-color 0.2s ease;
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
        }
        #setDisplayNameBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }


        .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; align-items: center;}
        .controls button, #sendBtn, #copyHostIdBtn {
            padding: 9px 15px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; transition: background-color 0.2s ease, color 0.2s ease;
            color: var(--chat-text-button);
        }
        .controls button#hostBtn, .controls button#connectBtn {
            background-color: var(--chat-bg-button-secondary);
            color: var(--chat-text-button-secondary);
        }
        .controls button#hostBtn:hover, .controls button#connectBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }
        #sendBtn, #copyHostIdBtn { background-color: var(--chat-bg-button-primary); }
        #sendBtn:hover, #copyHostIdBtn:hover { background-color: var(--chat-bg-button-primary-hover); }
        .controls button:disabled, #sendBtn:disabled, #copyHostIdBtn:disabled, #setDisplayNameBtn:disabled {
            background-color: var(--chat-bg-button-disabled) !important;
            color: #888 !important; cursor: not-allowed;
        }
        #copyHostIdBtn { margin-top: 5px; padding: 6px 10px; font-size: 0.85em; display: none; }

        .controls input[type="text"]#hostIdInput {
            flex-grow: 1; padding: 9px 12px; background-color: var(--chat-bg-input);
            color: var(--chat-text-input); border: 1px solid var(--chat-border-color);
            border-radius: 6px; font-size: 14px;
        }
        .controls input[type="text"]::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}

        #statusContainer { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; }
        #status { color: var(--chat-text-secondary); font-style: italic; text-align: center; padding: 6px;
                  background-color: var(--chat-bg-status); border-radius: 6px; font-size: 0.9em; width: 100%; margin-bottom: 4px;}
        #chat { height: 250px; background-color: var(--chat-bg-chat); border: 1px solid var(--chat-border-color);
                overflow-y: auto; margin-bottom: 12px; padding: 10px; border-radius: 6px; flex-grow: 1; }

        .message-item { margin-bottom: 8px; padding: 8px 12px; border-radius: 15px; max-width: 85%; word-wrap: break-word; }
        .message-item.local { background-color: var(--chat-msg-bg-local); color: #e1f5fe; margin-left: auto; border-bottom-right-radius: 5px; text-align: left; }
        body.chat-light-theme .message-item.local { color: var(--chat-text-button); }
        .message-item.remote { background-color: var(--chat-msg-bg-remote); color: var(--chat-text-primary); margin-right: auto; border-bottom-left-radius: 5px; }
        body.chat-light-theme .message-item.remote { color: var(--chat-text-input); }
        .message-item .sender-tag { font-weight: 600; margin-right: 5px; display: inline-block; font-size: 0.9em; }
        .message-item .sender-tag.host { color: #c59eff; } body.chat-light-theme .message-item .sender-tag.host { color: #8a2be2;}
        .message-item .sender-tag.you { color: #90caf9; } body.chat-light-theme .message-item .sender-tag.you { color: var(--chat-bg-button-primary);}
        .message-item .sender-tag.peer { color: #aaaaaa; } body.chat-light-theme .message-item .sender-tag.peer { color: #555555;}
        .message-item.system-msg { background-color: transparent; color: var(--chat-text-system); font-style: italic; font-size: 0.85em; text-align: center; max-width: 100%; padding: 4px 0; }

        #messageInput { width: calc(100% - 80px); background-color: var(--chat-bg-input); color: var(--chat-text-input);
                        border: 1px solid var(--chat-border-color); border-radius: 6px; font-size: 14px;
                        margin-right: 8px; padding: 9px 12px; }
        #messageInput::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}

        /* Modal Styles */
        .modal-overlay {
            display: none; position: fixed; z-index: 2000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: var(--chat-modal-bg);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--chat-modal-content-bg);
            margin: auto; padding: 20px;
            border: 1px solid var(--chat-border-color); border-radius: 8px;
            width: 80%; max-width: 320px; box-shadow: var(--chat-box-shadow);
            text-align: center; color: var(--chat-text-primary);
        }
        .modal-content p { margin-bottom: 20px; font-size: 1.05em; }
        .modal-buttons button {
            padding: 10px 18px; margin: 0 10px;
            border: none; border-radius: 6px; cursor: pointer; font-size: 14px;
            transition: background-color 0.2s ease;
        }
        .modal-buttons button#confirmClearBtn {
            background-color: var(--chat-bg-button-primary); color: var(--chat-text-button);
        }
        .modal-buttons button#confirmClearBtn:hover { background-color: var(--chat-bg-button-primary-hover); }
        .modal-buttons button#cancelClearBtn {
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
        }
        .modal-buttons button#cancelClearBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }

    </style>
</head>
<body>
    <div id="chatModuleWrapper">
        <div id="chatModuleContainer">
            <div id="moduleToggleBar">
                <span id="chatModuleTitle">P2P Chat</span>
                <div class="toggle-icon-group">
                    <span id="clearStorageIcon" class="toggle-icon" title="Clear Stored Data">üóëÔ∏è</span>
                    <span id="themeToggleIcon" class="toggle-icon" title="Toggle Theme">‚òÄÔ∏è</span>
                    <span id="collapseIcon" class="toggle-icon" title="Toggle Chat">üí¨</span>
                </div>
            </div>
            <div id="chatModuleContent">
                <div id="statusContainer">
                    <div id="status" class="status">Initializing...</div>
                    <button id="copyHostIdBtn">Copy Host ID</button>
                </div>
                <div class="name-control-group">
                    <input type="text" id="displayNameInput" placeholder="Your Name (max 30 chars)">
                    <button id="setDisplayNameBtn">Set Name</button>
                </div>
                <div class="controls">
                    <button id="hostBtn">Become Host</button>
                    <button id="connectBtn">Connect</button>
                    <input type="text" id="hostIdInput" placeholder="Host ID or blank for ServerOne">
                </div>
                <div id="chat"></div>
                <div style="display: flex; margin-top: auto;">
                    <input type="text" id="messageInput" placeholder="Type message...">
                    <button id="sendBtn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="clearStorageModal" class="modal-overlay">
        <div class="modal-content">
            <p>Are you sure you want to clear all stored chat data (theme, name, PeerID)?</p>
            <div class="modal-buttons">
                <button id="confirmClearBtn">Yes, Clear Data</button>
                <button id="cancelClearBtn">No, Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // --- Application Constants ---
        const MAX_PEER_INIT_ATTEMPTS = 5;
        const DEFAULT_PEER_ID_PREFIX = 'peerchat-';
        const SHORT_ID_LENGTH = 7;
        const DISPLAY_NAME_MAX_LENGTH = 30;
        const LOCAL_STORAGE_KEYS = {
            THEME: 'chatAppTheme',
            DISPLAY_NAME: 'chatUserDisplayName',
            PEER_ID: 'chatAppPeerId' // Stored PeerID can be a regular one or SERVER_ONE_PEER_ID if successfully acquired
        };
        // *** NEW: Well-known ID for the rendezvous peer ***
        const SERVER_ONE_PEER_ID = 'p2p-chat-rendezvous-serverone-202312'; // Make this unique and versioned

        // --- Application State Variables ---
        let peer;
        let hostConnection;
        let connections = {};
        let isHost = false; // User's *intent* to be a host
        let messageQueue = [];
        let myPeerId = null;
        let myDisplayName = null;
        let peerInitAttempts = 0;
        let isChatModuleCollapsed = false;
        let currentTheme = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME) || 'dark';

        // *** NEW: State for ServerOne logic ***
        let isActingAsServerOne = false; // True if this peer *is* currently SERVER_ONE_PEER_ID
        let currentConnectionTargetIsServerOne = false; // True if the current connection attempt is *to* SERVER_ONE_PEER_ID

        // --- DOM Element References ---
        const chatModuleContainerEl = document.getElementById('chatModuleContainer');
        const collapseIconEl = document.getElementById('collapseIcon');
        const themeToggleIconEl = document.getElementById('themeToggleIcon');
        const clearStorageIconEl = document.getElementById('clearStorageIcon');
        const statusEl = document.getElementById('status');
        const copyHostIdBtnEl = document.getElementById('copyHostIdBtn');
        const chatEl = document.getElementById('chat');
        const messageInputEl = document.getElementById('messageInput');
        const sendBtnEl = document.getElementById('sendBtn');
        const hostBtnEl = document.getElementById('hostBtn');
        const connectBtnEl = document.getElementById('connectBtn');
        const hostIdInputEl = document.getElementById('hostIdInput');
        const displayNameInputEl = document.getElementById('displayNameInput');
        const setDisplayNameBtnEl = document.getElementById('setDisplayNameBtn');
        const clearStorageModalEl = document.getElementById('clearStorageModal');
        const confirmClearBtnEl = document.getElementById('confirmClearBtn');
        const cancelClearBtnEl = document.getElementById('cancelClearBtn');

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        // --- Utility Functions ---
        function sanitizeHTML(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        function getShortPeerId(id) {
            if (!id) return 'unknown';
            if (id === SERVER_ONE_PEER_ID) return 'ServerOne';
            return id.slice(-SHORT_ID_LENGTH);
        }

        // *** MODIFIED: updateSelfStatusDisplay for ServerOne context ***
        function updateSelfStatusDisplay() {
            if (peer && peer.open) {
                const nameToDisplay = sanitizeHTML(myDisplayName || getShortPeerId(myPeerId));
                let statusText;
                if (isHost) {
                    if (isActingAsServerOne) {
                        statusText = `Hosting as ServerOne (${nameToDisplay}). Share ID: ${getShortPeerId(myPeerId)}`;
                    } else {
                        statusText = `Hosting as ${nameToDisplay}. Share ID: ${getShortPeerId(myPeerId)}`;
                    }
                } else if (hostConnection && hostConnection.open) {
                    const hostDisplayName = sanitizeHTML(hostConnection.displayName || `Host (${getShortPeerId(hostConnection.peer)})`);
                    if (hostConnection.peer === SERVER_ONE_PEER_ID) {
                        statusText = `Connected to ServerOne (${hostDisplayName}) as ${nameToDisplay}`;
                    } else {
                        statusText = `Connected to ${hostDisplayName} as ${nameToDisplay}`;
                    }
                } else {
                    statusText = "Ready. Set name. Host or Connect.";
                }
                updateStatus(statusText);
            } else {
                updateStatus(`Ready. Set name. Host or Connect (blank ID for ServerOne: ${getShortPeerId(SERVER_ONE_PEER_ID)}).`);
            }
        }

        // --- PeerJS Core Logic ---
        // *** MODIFIED: initializePeer to handle ServerOne hosting attempts ***
        function initializePeer(requestedPeerId = null, isAttemptingServerOneRoleForHost = false) {
            if (peer && !peer.destroyed) { console.warn("[P2P CHAT] PeerJS instance active. Destroying old one."); peer.destroy(); peer = null; }
            if (peer && peer.destroyed) { console.info("[P2P CHAT] Old PeerJS instance destroyed; re-initializing."); }

            peer = null; peerInitAttempts++;

            if (MAX_PEER_INIT_ATTEMPTS > 0 && peerInitAttempts > MAX_PEER_INIT_ATTEMPTS) {
                console.error(`[P2P CHAT] Max PeerJS init attempts (${MAX_PEER_INIT_ATTEMPTS}) reached.`);
                updateStatus("Failed to connect to signaling server. Try again.");
                hostBtnEl.disabled = false; connectBtnEl.disabled = false; // General re-enable
                return;
            }

            const storedPeerId = localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID);
            let peerIdToUse;

            if (requestedPeerId) {
                peerIdToUse = requestedPeerId;
            } else {
                peerIdToUse = storedPeerId || (DEFAULT_PEER_ID_PREFIX + Math.random().toString(36).substr(2, 9));
            }

            // If retrying a non-ServerOne host/client init, force new ID after first attempt
            if (!requestedPeerId && storedPeerId && peerInitAttempts > 1 && !isAttemptingServerOneRoleForHost) {
                 peerIdToUse = DEFAULT_PEER_ID_PREFIX + Math.random().toString(36).substr(2, 9);
                 console.info("[P2P CHAT] Forcing new PeerID on re-init for non-ServerOne/non-specific ID attempt.");
            }

            // Crucial: Store the ID we are *about to try*
            localStorage.setItem(LOCAL_STORAGE_KEYS.PEER_ID, peerIdToUse);
            myPeerId = peerIdToUse; // Tentatively set, will be confirmed by 'open' event
            console.info(`[P2P CHAT] Initializing PeerJS (Attempt ${peerInitAttempts}) with ID: ${myPeerId}${isAttemptingServerOneRoleForHost ? ' (Attempting ServerOne Host Role)' : ''}`);

            try {
                peer = new Peer(myPeerId, {
                    config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }, debug: 2
                });
            } catch (e) {
                console.error(`[P2P CHAT] Error creating PeerJS: ${e.message || e}`);
                updateStatus("Error initializing PeerJS. Retrying...");
                schedulePeerReinitialization(true, isHost && isAttemptingServerOneRoleForHost && requestedPeerId === SERVER_ONE_PEER_ID);
                return;
            }

            peer.on('open', (id) => {
                myPeerId = id; // Confirmed ID from PeerJS server
                localStorage.setItem(LOCAL_STORAGE_KEYS.PEER_ID, myPeerId);
                console.info(`[P2P CHAT] PeerJS OPENED. My ID: ${myPeerId}`);
                peerInitAttempts = 0; // Reset attempts on success

                if (isHost) { // User clicked "Become Host"
                    if (id === SERVER_ONE_PEER_ID && isAttemptingServerOneRoleForHost) {
                        isActingAsServerOne = true;
                        addMessage(`You are HOSTING as ServerOne (${sanitizeHTML(myDisplayName || getShortPeerId(myPeerId))}). ID: ${getShortPeerId(myPeerId)}`, 'system');
                    } else {
                        // This means either the ServerOne attempt resulted in a different ID (shouldn't happen if ID was free)
                        // OR this is the fallback random ID host initialization after ServerOne was unavailable.
                        isActingAsServerOne = false;
                        addMessage(`You are HOST (${sanitizeHTML(myDisplayName || getShortPeerId(myPeerId))}). ID: ${getShortPeerId(myPeerId)}`, 'system');
                    }
                    hostIdInputEl.value = myPeerId;
                    copyHostIdBtnEl.style.display = 'inline-block';
                    connectBtnEl.disabled = true; // Host cannot also connect
                    hostBtnEl.disabled = true;    // Already hosting
                } else { // Client mode
                    isActingAsServerOne = false;
                    copyHostIdBtnEl.style.display = 'none';
                    // Client buttons re-enabled by connect logic or error handling
                }
                updateSelfStatusDisplay();
                processMessageQueue();
            });

            peer.on('connection', (conn) => { setupConnectionObject(conn); });

            peer.on('error', (err) => {
                console.error(`[P2P CHAT] PeerJS Error: ${err.type} - ${err.message || err} (Current ID tried: ${myPeerId})`);
                let statusMessage = `Error: ${err.type}.`;
                let shouldRetryGeneral = false;
                let forceNewIdOnRetry = false;
                let retryServerOneHost = isHost && isAttemptingServerOneRoleForHost && requestedPeerId === SERVER_ONE_PEER_ID;


                if (err.type === 'unavailable-id') {
                    const unavailableId = myPeerId; // The ID that was unavailable
                    statusMessage = `ID ${getShortPeerId(unavailableId)} is unavailable.`;
                    localStorage.removeItem(LOCAL_STORAGE_KEYS.PEER_ID); // Remove the problematic ID
                    myPeerId = null; // Clear current ID

                    if (requestedPeerId === SERVER_ONE_PEER_ID && isAttemptingServerOneRoleForHost && isHost) {
                        // Specific case: Tried to host as ServerOne, but it's taken. Fallback to regular host.
                        console.warn(`[P2P CHAT] SERVER_ONE_PEER_ID (${SERVER_ONE_PEER_ID}) is unavailable. Initializing as regular host with a new random ID.`);
                        statusMessage += " Trying as regular host.";
                        updateStatus(statusMessage);
                        if (peer && !peer.destroyed) peer.destroy(); peer = null;
                        initializePeer(null, false); // Initialize with random ID, explicitly not as ServerOne. isHost is still true.
                        return; // Handled, exit.
                    } else {
                        // General unavailable ID (e.g. client provided a bad one, or stored ID is bad)
                        forceNewIdOnRetry = true;
                        shouldRetryGeneral = true;
                        retryServerOneHost = false; // Don't retry ServerOne if it was a general unavailable ID.
                    }
                } else if (['network', 'server-error', 'socket-error', 'socket-closed'].includes(err.type)) {
                    statusMessage += " Retrying connection to signaling server.";
                    shouldRetryGeneral = true;
                    // If it was an attempt for ServerOne and failed due to network, retryServerOneHost remains true.
                } else if (err.type === 'peer-unavailable' && err.message) {
                    const failedTargetPeerIdRaw = err.message.split(' ').pop();
                    if (currentConnectionTargetIsServerOne && failedTargetPeerIdRaw.includes(SERVER_ONE_PEER_ID)) {
                        statusMessage = `Default rendezvous ServerOne (${getShortPeerId(SERVER_ONE_PEER_ID)}) is not available.`;
                    } else {
                        statusMessage = `Could not connect to peer: ${getShortPeerId(failedTargetPeerIdRaw)}`;
                    }
                    currentConnectionTargetIsServerOne = false; // Reset flag
                    connectBtnEl.disabled = false; // Allow user to try again or host
                    if (!isHost) hostBtnEl.disabled = false;
                    // No automatic retry for peer-unavailable
                } else if (err.type === 'disconnected') { // This is PeerJS server disconnection
                     statusMessage = 'Disconnected from PeerJS server. Reconnecting...';
                     shouldRetryGeneral = true;
                     retryServerOneHost = isHost && isActingAsServerOne; // If I *was* ServerOne, try to reclaim.
                }else {
                    // For other errors, allow manual retry.
                    connectBtnEl.disabled = false;
                    if (!isHost) hostBtnEl.disabled = false;
                }

                updateStatus(statusMessage);
                if (shouldRetryGeneral) {
                     schedulePeerReinitialization(forceNewIdOnRetry, retryServerOneHost);
                }
            });

            peer.on('disconnected', () => { // This is explicit disconnection from PeerJS signaling server
                console.warn('[P2P CHAT] Disconnected from PeerJS server. Reconnecting...');
                updateStatus('Disconnected. Reconnecting...');
                const shouldRetryServerOne = isHost && isActingAsServerOne; // If I *was* ServerOne, try to reclaim.
                schedulePeerReinitialization(false, shouldRetryServerOne);
            });

            peer.on('close', () => {
                console.warn('[P2P CHAT] PeerJS connection closed permanently.');
                updateStatus('Connection closed. Re-initialize manually.'); peer = null;
                hostBtnEl.disabled = false; connectBtnEl.disabled = false;
                copyHostIdBtnEl.style.display = 'none'; peerInitAttempts = 0;
                isActingAsServerOne = false; // No longer acting as ServerOne
            });
        }

        // *** MODIFIED: schedulePeerReinitialization to pass ServerOne host intent ***
        function schedulePeerReinitialization(forceNewId = false, retryServerOneHostAttempt = false) {
            if (forceNewId) { localStorage.removeItem(LOCAL_STORAGE_KEYS.PEER_ID); myPeerId = null; }
            if (peer && !peer.destroyed) { peer.destroy(); } peer = null;

            const delay = Math.min(3000 + (peerInitAttempts * 2000), 15000); // Slightly increase retry delay base
            console.info(`[P2P CHAT] Scheduling PeerJS re-init in ${delay / 1000}s. New ID: ${forceNewId}, Retry ServerOne Host: ${retryServerOneHostAttempt}`);

            setTimeout(() => {
                if (retryServerOneHostAttempt && isHost) { // isHost must still be true
                    initializePeer(SERVER_ONE_PEER_ID, true);
                } else {
                    // If forceNewId, requestedId will be null, otherwise it might use stored ID.
                    // Second param is isAttemptingServerOneRoleForHost, which should be false for general retries.
                    initializePeer(forceNewId ? null : localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID), false);
                }
            }, delay);
        }


        function sendEncoded(conn, dataObject) { /* ... (no change) ... */ }
        function setupConnectionObject(conn) {
             const connId = conn.peer; conn.displayName = conn.metadata?.name || null;
            if (isHost) {
                connections[connId] = conn;
                console.info(`[P2P CHAT] Incoming connection: ${getShortPeerId(connId)}${conn.displayName ? ` (${sanitizeHTML(conn.displayName)})` : ''}`);
            } else { // Client connected to a host
                hostConnection = conn;
                console.info(`[P2P CHAT] Establishing connection with host: ${getShortPeerId(connId)}${conn.displayName ? ` (${sanitizeHTML(conn.displayName)})` : ''}`);
            }

            conn.on('open', () => {
                const remoteIdentifier = sanitizeHTML(conn.displayName || getShortPeerId(connId));
                console.info(`[P2P CHAT] DataConnection to ${remoteIdentifier} (ID: ${getShortPeerId(connId)}) OPENED.`);
                addMessage(`${remoteIdentifier} connected.`, 'system');
                updateSelfStatusDisplay();

                currentConnectionTargetIsServerOne = false; // Connection successful, clear flag

                // Enable/disable buttons based on successful connection
                if (!isHost) { // If I am a client and successfully connected
                    connectBtnEl.disabled = true;
                    hostBtnEl.disabled = true; // Cannot become host if connected as client
                }
                // If I am a host, my buttons are already set.

                if (isHost) {
                    sendEncoded(conn, { type: 'host-announcement', hostId: myPeerId, hostName: myDisplayName || getShortPeerId(myPeerId), isServerOne: isActingAsServerOne });
                    setTimeout(() => { /* ... (chat history logic, no change needed for ServerOne) ... */ }, 500);
                }
                processMessageQueue();
            });

            conn.on('data', (receivedData) => { /* ... (no change, but handle host-announcement's isServerOne flag) ... */ });
            // In handleIncomingData, for 'host-announcement':
            // if (dataObject.isServerOne) { addMessage(`Host is ServerOne rendezvous.`, 'system'); }


            conn.on('close', () => {
                const remoteIdentifier = sanitizeHTML(conn.displayName || getShortPeerId(connId));
                console.warn(`[P2P CHAT] DataConnection to ${remoteIdentifier} CLOSED.`);
                addMessage(`${remoteIdentifier} disconnected.`, 'system');
                currentConnectionTargetIsServerOne = false; // Clear flag on close

                if (isHost) { delete connections[connId];
                } else if (hostConnection && hostConnection.peer === connId) { // Client's connection to host closed
                    hostConnection = null; hostIdInputEl.value = '';
                    connectBtnEl.disabled = false; // Allow client to reconnect or host
                    if (!isHost) hostBtnEl.disabled = false;
                }
                updateSelfStatusDisplay();
            });
             conn.on('error', (err) => {
                console.error(`[P2P CHAT] DataConnection error with ${getShortPeerId(connId)}: ${err.type} - ${err.message || err}`);
                currentConnectionTargetIsServerOne = false; // Clear flag on error
            });
        }

        function handleIncomingData(dataObject, fromId, connectionInstance) {
            const senderIdentifier = dataObject.senderName || dataObject.name || (connectionInstance ? connectionInstance.displayName : null) || getShortPeerId(fromId);
            console.info(`[P2P CHAT] Decoded Data: type=${dataObject.type} from ${senderIdentifier} (ID: ${getShortPeerId(fromId)})`);
            switch (dataObject.type) {
                case 'chat-message': /* ... (no change) ... */ break;
                case 'name-update': /* ... (no change) ... */ break;
                case 'host-announcement':
                    if (!isHost) {
                        const hostName = dataObject.hostName || getShortPeerId(dataObject.hostId);
                        if (connectionInstance) connectionInstance.displayName = dataObject.hostName;
                        addMessage(`Connected to host: ${sanitizeHTML(hostName)}`, 'system');
                        if (dataObject.isServerOne) { // *** NEW: Check if host is ServerOne ***
                            addMessage(`This host is acting as ServerOne rendezvous.`, 'system');
                        }
                        updateSelfStatusDisplay();
                    }
                    break;
                case 'client-info': /* ... (no change) ... */ break;
                case 'chat-history': /* ... (no change) ... */ break;
                default: console.warn(`[P2P CHAT] Unknown data type: ${dataObject.type}.`);
            }
        }

        function processMessageQueue() { /* ... (no change) ... */ }
        function broadcastMessage(text) { /* ... (no change) ... */ }
        function sendToHost(text) { /* ... (no change) ... */ }

        // --- UI Interaction Functions ---
        function updateStatus(text) { statusEl.innerHTML = sanitizeHTML(text); }
        function addMessage(text, senderId, senderNameFromNetwork) { /* ... (no change) ... */ }
        function updateChatLogDisplayName(peerIdToUpdate, newDisplayName) { /* ... (no change) ... */ }
        function applyTheme(theme) { /* ... (no change) ... */ }
        function toggleChatModule() { /* ... (no change) ... */ }

        // --- Event Listeners for UI Elements ---
        setDisplayNameBtnEl.addEventListener('click', () => { /* ... (no change) ... */ });

        // *** MODIFIED: Host Button Logic ***
        hostBtnEl.addEventListener('click', () => {
            console.info('[P2P CHAT] "Become Host" clicked.');
            isHost = true; // Set user's *intent* to be a host
            isActingAsServerOne = false; // Reset this, will be set in initializePeer if successful
            currentConnectionTargetIsServerOne = false; // Not trying to connect

            hostBtnEl.disabled = true; connectBtnEl.disabled = true; // Disable while attempting
            copyHostIdBtnEl.style.display = 'none';

            if (peer && !peer.destroyed) { peer.destroy(); } peer = null; // Clean up existing peer
            peerInitAttempts = 0;

            // Attempt to initialize as SERVER_ONE_PEER_ID first.
            // The second parameter 'true' indicates this is an attempt to become ServerOne as a host.
            initializePeer(SERVER_ONE_PEER_ID, true);
        });

        // *** MODIFIED: Connect Button Logic ***
        connectBtnEl.addEventListener('click', () => {
            console.info('[P2P CHAT] "Connect" clicked.');
            isHost = false; isActingAsServerOne = false; // Definitely a client
            hostBtnEl.disabled = true; connectBtnEl.disabled = true; // Disable while attempting
            copyHostIdBtnEl.style.display = 'none';

            let remoteHostId = hostIdInputEl.value.trim();

            if (!remoteHostId) { // If input is blank, try to connect to ServerOne
                remoteHostId = SERVER_ONE_PEER_ID;
                currentConnectionTargetIsServerOne = true; // Set flag for contextual error messages
                addMessage(`Attempting to connect to default rendezvous: ServerOne (${getShortPeerId(SERVER_ONE_PEER_ID)})...`, 'system');
                // hostIdInputEl.value = SERVER_ONE_PEER_ID; // Optionally fill input
            } else {
                currentConnectionTargetIsServerOne = false;
                addMessage(`Attempting to connect to: ${getShortPeerId(remoteHostId)}...`, 'system');
            }

            if (myPeerId && remoteHostId === myPeerId) {
                addMessage("Cannot connect to self.", 'system');
                connectBtnEl.disabled = false; if (!isHost) hostBtnEl.disabled = false; // Re-enable
                return;
            }

            const connectOptions = {
                reliable: true, serialization: 'binary',
                metadata: { name: myDisplayName || getShortPeerId(myPeerId) }
            };

            if (!peer || peer.destroyed || !peer.open) {
                console.info("[P2P CHAT] Local PeerJS not ready, initializing first for client connection.");
                if (peer && !peer.destroyed) { peer.destroy(); } peer = null;
                peerInitAttempts = 0;

                const onOpenConnect = () => {
                    if(peer) { peer.off('open', onOpenConnect); peer.off('error', onErrorConnect); }
                    if (peer && peer.open && !peer.destroyed) {
                        console.info(`[P2P CHAT] Local PeerJS opened (ID: ${myPeerId}), now connecting to remote host: ${remoteHostId}`);
                        hostConnection = peer.connect(remoteHostId, connectOptions);
                        setupConnectionObject(hostConnection);
                    } else {
                        console.error("[P2P CHAT] Local PeerJS failed to open for connection attempt.");
                        addMessage("Connection init failed: Local peer not ready.", "system");
                        connectBtnEl.disabled = false; if(!isHost) hostBtnEl.disabled = false;
                        updateSelfStatusDisplay();
                        currentConnectionTargetIsServerOne = false;
                    }
                };
                const onErrorConnect = (err) => { // Error during *local* peer initialization
                    if(peer) { peer.off('open', onOpenConnect); peer.off('error', onErrorConnect); }
                    console.error(`[P2P CHAT] Error initializing local PeerJS for connect: ${err.type}`);
                    // The global peer.on('error') handler in initializePeer will manage status and retries.
                    // We just need to ensure buttons are re-enabled if it's a fatal, non-retrying error for local peer.
                    // addMessage("Error initializing local connection. Try again.", "system");
                    // connectBtnEl.disabled = false; if(!isHost) hostBtnEl.disabled = false;
                    // updateSelfStatusDisplay();
                    currentConnectionTargetIsServerOne = false;
                };

                initializePeer(null, false); // Initialize local peer with random ID, not as ServerOne host
                if (peer) { // initializePeer creates peer synchronously
                    peer.on('open', onOpenConnect);
                    // Error during local init is handled by the main peer.on('error') in initializePeer
                    // peer.on('error', onErrorConnect); // This might conflict with the one in initializePeer
                } else {
                     console.error("[P2P CHAT] Peer object not created by initializePeer for client.");
                     addMessage("Failed to start local connection infrastructure.", "system");
                     connectBtnEl.disabled = false; if(!isHost) hostBtnEl.disabled = false; updateSelfStatusDisplay();
                     currentConnectionTargetIsServerOne = false;
                }
            } else { // Local peer is already initialized and open
                console.info(`[P2P CHAT] Local PeerJS ready (ID: ${myPeerId}), connecting to remote host: ${remoteHostId}`);
                hostConnection = peer.connect(remoteHostId, connectOptions);
                setupConnectionObject(hostConnection);
            }
        });

        function sendMessageHandler() { /* ... (no change) ... */ }
        sendBtnEl.addEventListener('click', sendMessageHandler);
        messageInputEl.addEventListener('keypress', (e) => { /* ... (no change) ... */ });
        collapseIconEl.addEventListener('click', toggleChatModule);
        themeToggleIconEl.addEventListener('click', () => { /* ... (no change) ... */ });
        clearStorageIconEl.addEventListener('click', () => { /* ... (no change) ... */ });
        confirmClearBtnEl.addEventListener('click', () => { /* ... (no change) ... */ });
        cancelClearBtnEl.addEventListener('click', () => { /* ... (no change) ... */ });
        window.addEventListener('click', (event) => { /* ... (no change) ... */ });
        copyHostIdBtnEl.addEventListener('click', () => { /* ... (no change) ... */ });

        // --- Initial Application Setup ---
        function main() {
            myDisplayName = localStorage.getItem(LOCAL_STORAGE_KEYS.DISPLAY_NAME);
            if (myDisplayName) {
                displayNameInputEl.value = myDisplayName;
                setDisplayNameBtnEl.textContent = "Update Name";
            } else { setDisplayNameBtnEl.textContent = "Set Name"; }

            currentTheme = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME) || 'dark';
            applyTheme(currentTheme);

            // *** MODIFIED: Placeholder text for hostIdInput ***
            hostIdInputEl.placeholder = `Host ID or blank for ServerOne (${getShortPeerId(SERVER_ONE_PEER_ID)})`;

            updateSelfStatusDisplay(); // Will show initial "Ready..." status
            const welcomeName = myDisplayName ? `, ${sanitizeHTML(myDisplayName)}` : '';
            addMessage(`Welcome${welcomeName}! Set/confirm name, then Host or Connect.`, "system");

            copyHostIdBtnEl.style.display = 'none';
            collapseIconEl.innerHTML = '‚úñÔ∏è'; collapseIconEl.title = 'Close Chat';
        }

        main();
    </script>
</body>
</html>
