<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat - V7 Complete</title>
    <style>
        /* --- Theme Variables --- */
        :root { /* Default: Dark Theme */
            --chat-bg-body: #1a1a1a; --chat-bg-container: #2d2d2d; --chat-bg-input: #3c3c3c;
            --chat-bg-chat: #252525; --chat-bg-status-area: #333333; --chat-bg-button-primary: #007acc;
            --chat-bg-button-primary-hover: #005fa3; --chat-bg-button-secondary: #505050;
            --chat-bg-button-secondary-hover: #606060; --chat-bg-button-disabled: #404040;
            --chat-text-primary: #e0e0e0; --chat-text-secondary: #b0b0b0; --chat-text-input: #f0f0f0;
            --chat-text-button: #ffffff; --chat-text-button-secondary: #e0e0e0; --chat-text-system: #9e9e9e;
            --chat-border-color: #4a4a4a; --chat-msg-bg-local: #004d7a; --chat-msg-bg-remote: #3e4042;
            --chat-icon-color: #b0b0b0; --chat-icon-hover-color: #ffffff; --chat-box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            --chat-modal-bg: rgba(0, 0, 0, 0.6); --chat-modal-content-bg: var(--chat-bg-container);
            --chat-section-bg: #292929;
        }
        body.chat-light-theme { /* Light Theme Overrides */
            --chat-bg-body: #f4f6f8; --chat-bg-container: #ffffff; --chat-bg-input: #f0f0f0;
            --chat-bg-chat: #f5f5f5; --chat-bg-status-area: #e9ecef; --chat-bg-button-primary: #007bff;
            --chat-bg-button-primary-hover: #0056b3; --chat-bg-button-secondary: #6c757d;
            --chat-bg-button-secondary-hover: #545b62; --chat-bg-button-disabled: #cccccc;
            --chat-text-primary: #212529; --chat-text-secondary: #495057; --chat-text-input: #333333;
            --chat-text-button: #ffffff; --chat-text-button-secondary: #ffffff; --chat-text-system: #6c757d;
            --chat-border-color: #ced4da; --chat-msg-bg-local: #007bff; --chat-msg-bg-remote: #e9ecef;
            --chat-icon-color: #495057; --chat-icon-hover-color: #000000; --chat-box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            --chat-modal-bg: rgba(0, 0, 0, 0.4); --chat-modal-content-bg: var(--chat-bg-container);
            --chat-section-bg: #f8f9fa;
        }
        /* Base & Layout */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--chat-bg-body); color: var(--chat-text-primary); margin: 0; padding: 0; font-size: 15px; line-height: 1.6; transition: background-color 0.2s ease-out, color 0.2s ease-out; }
        #chatModuleWrapper { position: fixed; bottom: 20px; right: 20px; z-index: 1000; transition: all 0.3s ease-in-out; }
        #chatModuleContainer { width: 380px; max-height: calc(100vh - 40px); display: flex; flex-direction: column; background-color: var(--chat-bg-container); color: var(--chat-text-primary); border-radius: 10px; box-shadow: var(--chat-box-shadow); border: 1px solid var(--chat-border-color); overflow: hidden; transition: width 0.25s ease-out, height 0.25s ease-out, opacity 0.25s ease-out, transform 0.25s ease-out; transform-origin: bottom right; }
        #chatModuleContent { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 350px; }
        /* Top Bar */
        #moduleToggleBar { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background-color: var(--chat-bg-status-area); border-bottom: 1px solid var(--chat-border-color); user-select: none; cursor: default; flex-shrink: 0; }
        #chatModuleTitle { font-weight: 500; font-size: 1.05em; }
        .toggle-icon-group { display: flex; align-items: center; }
        .toggle-icon { cursor: pointer; font-size: 20px; padding: 5px; margin-left: 6px; line-height: 1; color: var(--chat-icon-color); transition: color 0.2s ease, transform 0.15s ease; display: inline-flex; align-items: center; justify-content: center; border-radius: 4px; }
        .toggle-icon:hover { color: var(--chat-icon-hover-color); background-color: rgba(120,120,120,0.15);} .toggle-icon:active { transform: scale(0.9); }
        /* Setup Section (Collapsible) */
        .control-section#setupSection { background-color: var(--chat-section-bg); padding: 0; border-radius: 6px; margin-bottom: 10px; border: 1px solid var(--chat-border-color); flex-shrink: 0; transition: margin-bottom 0.3s ease-in-out; }
        .control-section#setupSection .section-title { font-size: 0.8em; text-transform: uppercase; letter-spacing: 0.5px; color: var(--chat-text-secondary); margin:0; padding: 8px 10px; border-bottom: 1px solid var(--chat-border-color); background-color: var(--chat-bg-status-area); border-top-left-radius: 6px; border-top-right-radius: 6px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;}
        .control-section#setupSection .section-title span { font-size: 0.8em; transition: transform 0.2s ease-in-out; }
        .control-section#setupSection.collapsed .section-title span { transform: rotate(-90deg); }
        .control-section#setupSection .section-content { padding: 10px; max-height: 500px; overflow: hidden; transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out, border 0.3s ease-in-out; border-top: 1px solid transparent; }
        .control-section#setupSection.collapsed .section-content { max-height: 0; padding-top: 0; padding-bottom: 0; border-top: 1px solid var(--chat-border-color); margin-top:-1px;}
        .control-section#setupSection.collapsed { margin-bottom: 0; }
        /* Status Area (inside setup) */
        #statusArea { margin-bottom: 10px; padding: 8px; background-color: var(--chat-bg-status-area); border-radius: 6px; }
        #status { color: var(--chat-text-secondary); font-style: italic; text-align: center; font-size: 0.9em; width: 100%; margin-bottom: 4px; word-wrap: break-word; }
        #peerIdDisplayArea { display: none; text-align: center; font-size: 0.85em; color: var(--chat-text-secondary); margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--chat-border-color); }
        #myPeerIdValue { font-weight: bold; color: var(--chat-text-primary); user-select: all; word-break: break-all; display: inline-block; margin-right: 5px;}
        #copyMyIdBtn { padding: 4px 8px; font-size: 0.8em; background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary); border: none; border-radius: 4px; cursor: pointer; vertical-align: middle; }
        #copyMyIdBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }
        /* Controls (inside setup) */
        .name-control-group { display: flex; gap: 8px; align-items: center; margin-bottom: 12px; }
        #displayNameInput { flex-grow: 1; padding: 8px 10px; background-color: var(--chat-bg-input); color: var(--chat-text-input); border: 1px solid var(--chat-border-color); border-radius: 6px; font-size: 14px; }
        #setDisplayNameBtn { padding: 8px 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s ease; background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary); flex-shrink: 0; }
        #setDisplayNameBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }
        .connection-buttons-row { display: flex; gap: 8px; margin-bottom: 8px; }
        .connection-buttons-row button { flex-grow: 1; width: 50%; padding: 8px 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s ease; background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary); }
        .connection-buttons-row button:hover { background-color: var(--chat-bg-button-secondary-hover); }
        #connectSectionInput input[type="text"]#hostIdInput { width: 100%; box-sizing: border-box; padding: 8px 10px; background-color: var(--chat-bg-input); color: var(--chat-text-input); border: 1px solid var(--chat-border-color); border-radius: 6px; font-size: 14px;}
        #connectSectionInput input[type="text"]::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}
        /* Chat & Input Area */
        #chat { background-color: var(--chat-bg-chat); border: 1px solid var(--chat-border-color); overflow-y: auto; margin-bottom: 10px; padding: 10px; border-radius: 6px; flex-grow: 1; flex-shrink: 1; min-height: 100px; }
        #messageInputArea { display: flex; margin-top: auto; flex-shrink: 0; padding-top: 5px; }
        #messageInput { flex-grow: 1; background-color: var(--chat-bg-input); color: var(--chat-text-input); border: 1px solid var(--chat-border-color); border-radius: 6px; font-size: 14px; margin-right: 8px; padding: 8px 10px; }
        #messageInput::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}
        #sendBtn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s ease, color 0.2s ease; background-color: var(--chat-bg-button-primary); color: var(--chat-text-button); flex-shrink: 0; }
        #sendBtn:hover { background-color: var(--chat-bg-button-primary-hover); }
        /* Messages */
        .message-item { margin-bottom: 8px; padding: 8px 12px; border-radius: 15px; max-width: 85%; word-wrap: break-word; line-height: 1.4; }
        .message-item.local { background-color: var(--chat-msg-bg-local); color: #e1f5fe; margin-left: auto; border-bottom-right-radius: 5px; text-align: left; } body.chat-light-theme .message-item.local { color: var(--chat-text-button); }
        .message-item.remote { background-color: var(--chat-msg-bg-remote); color: var(--chat-text-primary); margin-right: auto; border-bottom-left-radius: 5px; } body.chat-light-theme .message-item.remote { color: var(--chat-text-input); }
        .message-item .sender-tag { font-weight: 600; margin-right: 5px; display: inline-block; font-size: 0.9em; }
        .message-item .sender-tag.peer { color: #aaaaaa; } body.chat-light-theme .message-item .sender-tag.peer { color: #555555;}
        .message-item .sender-tag.you { color: #90caf9; } body.chat-light-theme .message-item .sender-tag.you { color: var(--chat-bg-button-primary);}
        .message-item.system-msg { background-color: transparent; color: var(--chat-text-system); font-style: italic; font-size: 0.85em; text-align: center; max-width: 100%; padding: 4px 0; }
        /* Other UI */
        #hostBtn:disabled, #connectBtn:disabled, #sendBtn:disabled, #setDisplayNameBtn:disabled, #copyMyIdBtn:disabled { background-color: var(--chat-bg-button-disabled) !important; color: #888 !important; cursor: not-allowed; opacity: 0.7; }
        .modal-overlay { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: var(--chat-modal-bg); justify-content: center; align-items: center; }
        .modal-content { background-color: var(--chat-modal-content-bg); margin: auto; padding: 20px; border: 1px solid var(--chat-border-color); border-radius: 8px; width: 80%; max-width: 320px; box-shadow: var(--chat-box-shadow); text-align: center; color: var(--chat-text-primary); }
        .modal-content p { margin-bottom: 20px; font-size: 1.05em; }
        .modal-buttons button { padding: 10px 18px; margin: 0 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background-color 0.2s ease; }
        .modal-buttons button#confirmClearBtn { background-color: var(--chat-bg-button-primary); color: var(--chat-text-button); } .modal-buttons button#confirmClearBtn:hover { background-color: var(--chat-bg-button-primary-hover); }
        .modal-buttons button#cancelClearBtn { background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary); } .modal-buttons button#cancelClearBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }
        /* Collapse / Full Frame */
        #chatModuleContainer.collapsed { width: 48px; height: 48px; padding: 0; overflow: visible; border: none; background-color: transparent; box-shadow: none; }
        #chatModuleContainer.collapsed > *:not(#moduleToggleBar) { display: none !important; }
        #chatModuleContainer.collapsed #moduleToggleBar { padding: 0; background-color: var(--chat-bg-button-secondary); width: 48px; height: 48px; border-radius: 50%; justify-content: center; align-items: center; border-bottom: none; box-shadow: var(--chat-box-shadow); cursor: pointer; }
        #chatModuleContainer.collapsed #moduleToggleBar #chatModuleTitle, #chatModuleContainer.collapsed #moduleToggleBar #fullFrameToggleIcon, #chatModuleContainer.collapsed #moduleToggleBar #themeToggleIcon, #chatModuleContainer.collapsed #moduleToggleBar #clearStorageIcon { display: none !important; }
        #chatModuleContainer.collapsed #moduleToggleBar #collapseIcon { display: inline-flex !important; align-items: center; justify-content: center; width: 100%; height: 100%; margin: 0; padding: 0; font-size: 22px; line-height: 1; border-radius: 0; }
        #chatModuleWrapper.full-frame-mode { width: 100%; height: 100%; bottom: 0; right: 0; top: 0; left: 0; padding:0; }
        #chatModuleWrapper.full-frame-mode #chatModuleContainer { width: 100%; height: 100%; max-height: 100vh; border-radius: 0; border: none; }
        #chatModuleWrapper.full-frame-mode #chatModuleContainer.collapsed > *:not(#moduleToggleBar) { display: flex !important; }
        #chatModuleWrapper.full-frame-mode #collapseIcon { display: none !important; }
    </style>
</head>
<body>
    <div id="chatModuleWrapper">
        <div id="chatModuleContainer">
            <div id="moduleToggleBar">
                <span id="chatModuleTitle">P2P Chat</span>
                <div class="toggle-icon-group">
                    <span id="fullFrameToggleIcon" class="toggle-icon" title="Toggle Full Frame">‚ÜóÔ∏è</span>
                    <span id="clearStorageIcon" class="toggle-icon" title="Clear Stored Data">üóëÔ∏è</span>
                    <span id="themeToggleIcon" class="toggle-icon" title="Toggle Theme">‚òÄÔ∏è</span>
                    <span id="collapseIcon" class="toggle-icon" title="Toggle Chat Window">‚úñÔ∏è</span>
                </div>
            </div>
            <div id="chatModuleContent">

                 <div id="setupSection" class="control-section collapsible"> <!-- Collapsible Setup -->
                    <p class="section-title" id="setupSectionTitle">Setup & Connection <span>üîΩ</span></p>
                    <div class="section-content">
                        <div id="statusArea">
                             <div id="status" class="status">Initializing...</div>
                             <div id="peerIdDisplayArea"> <!-- ID display moved inside -->
                                Your Peer ID: <span id="myPeerIdValue"></span>
                                <button id="copyMyIdBtn" disabled>Copy</button>
                            </div>
                        </div>
                         <div class="name-control-group">
                            <input type="text" id="displayNameInput" placeholder="Your Name (max 25 chars)">
                            <button id="setDisplayNameBtn">Set Name</button>
                        </div>
                        <hr style="border-color: var(--chat-border-color); border-style: dashed; margin: 12px 0;">
                        <div class="connection-buttons-row">
                            <button id="hostBtn">Ready to Host</button>
                            <button id="connectBtn">Connect to Peer</button>
                        </div>
                        <div id="connectSectionInput">
                            <input type="text" id="hostIdInput" placeholder="Enter Peer ID to Connect">
                        </div>
                    </div>
                </div>

                <div id="chat"></div>

                <div id="messageInputArea">
                    <input type="text" id="messageInput" placeholder="Type message..." disabled>
                    <button id="sendBtn" disabled>Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="clearStorageModal" class="modal-overlay">
         <div class="modal-content">
            <p>Are you sure you want to clear stored chat data?</p>
            <div class="modal-buttons">
                <button id="confirmClearBtn">Yes, Clear</button>
                <button id="cancelClearBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        "use strict";

        // --- Constants ---
        const MAX_PEER_INIT_ATTEMPTS = 4; const DEFAULT_PEER_ID_PREFIX = 'p2pchat-';
        const SHORT_ID_LENGTH = 6; const DISPLAY_NAME_MAX_LENGTH = 25;
        const LOCAL_STORAGE_KEYS = { THEME: 'p2pChatTheme_v7', DISPLAY_NAME: 'p2pChatDisplayName_v7', PEER_ID: 'p2pChatPeerId_v7', IS_FULL_FRAME: 'p2pChatIsFullFrame_v7', IS_SETUP_COLLAPSED: 'p2pChatIsSetupCollapsed_v7' };
        const MAX_CONSECUTIVE_SERVER_ERRORS = 3;

        // --- State ---
        let peer; let currentPeerConnection = null;
        let isReadyToHost = false; let messageQueue = []; let myPeerId = null;
        let myDisplayName = null; let peerInitAttempts = 0; let isChatModuleCollapsed = false;
        let currentTheme = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME) || 'dark';
        let isFullFrame = localStorage.getItem(LOCAL_STORAGE_KEYS.IS_FULL_FRAME) === 'true';
        let isSetupSectionCollapsed = localStorage.getItem(LOCAL_STORAGE_KEYS.IS_SETUP_COLLAPSED) === 'true';
        let peerJsServerErrorCount = 0;

        // --- DOM Refs ---
        // (Assume all document.getElementById calls are here and correctly map to HTML)
        const chatModuleWrapper=document.getElementById('chatModuleWrapper'); const chatModuleContainerEl=document.getElementById('chatModuleContainer');
        const collapseIconEl=document.getElementById('collapseIcon'); const themeToggleIconEl=document.getElementById('themeToggleIcon');
        const clearStorageIconEl=document.getElementById('clearStorageIcon'); const fullFrameToggleIconEl=document.getElementById('fullFrameToggleIcon');
        const statusEl=document.getElementById('status'); const setupSectionEl=document.getElementById('setupSection');
        const setupSectionTitleEl=document.getElementById('setupSectionTitle'); const peerIdDisplayAreaEl=document.getElementById('peerIdDisplayArea');
        const myPeerIdValueEl=document.getElementById('myPeerIdValue'); const copyMyIdBtnEl=document.getElementById('copyMyIdBtn');
        const chatEl=document.getElementById('chat'); const messageInputAreaEl=document.getElementById('messageInputArea');
        const messageInputEl=document.getElementById('messageInput'); const sendBtnEl=document.getElementById('sendBtn');
        const hostBtnEl=document.getElementById('hostBtn'); const connectBtnEl=document.getElementById('connectBtn');
        const hostIdInputEl=document.getElementById('hostIdInput'); const displayNameInputEl=document.getElementById('displayNameInput');
        const setDisplayNameBtnEl=document.getElementById('setDisplayNameBtn'); const clearStorageModalEl=document.getElementById('clearStorageModal');
        const confirmClearBtnEl=document.getElementById('confirmClearBtn'); const cancelClearBtnEl=document.getElementById('cancelClearBtn');


        const textEncoder = new TextEncoder(); const textDecoder = new TextDecoder();

        // --- UTILS ---
        function sanitizeHTML(str){if(typeof str !== 'string')return ''; const t=document.createElement('div'); t.textContent=str; return t.innerHTML;}
        function getShortPeerId(id){if(!id)return '???'; return id.slice(-SHORT_ID_LENGTH);}
        function updateStatusUI(text){if(statusEl)statusEl.innerHTML=sanitizeHTML(text); else { console.error("!!! statusEl not found in updateStatusUI !!!"); } }
        function logInfo(msg, ...args){console.info(`[P2P INFO] ${msg}`, ...args);}
        function logWarn(msg, ...args){console.warn(`[P2P WARN] ${msg}`, ...args);}
        function logError(msg, ...args){console.error(`[P2P ERROR] ${msg}`, ...args);}

        // --- CORE UI ---
        function applyTheme(theme){ if(!document.body||!themeToggleIconEl){logError("applyTheme: Missing body or icon"); return;} logInfo('Applying theme:', theme); document.body.classList.remove('chat-light-theme','chat-dark-theme'); document.body.classList.add(theme==='light'?'chat-light-theme':'chat-dark-theme'); themeToggleIconEl.innerHTML=theme==='light'?'üåô':'‚òÄÔ∏è'; themeToggleIconEl.title=`To ${theme==='light'?'Dark':'Light'}`; currentTheme=theme; localStorage.setItem(LOCAL_STORAGE_KEYS.THEME,theme); }
        function toggleChatModule(){ if(!chatModuleContainerEl||!collapseIconEl){logError("toggleChatModule: Missing container or icon"); return;} logInfo('Toggling chat module collapse'); if(isFullFrame){logWarn('Cannot collapse in full frame mode'); return;} isChatModuleCollapsed=!isChatModuleCollapsed; chatModuleContainerEl.classList.toggle('collapsed',isChatModuleCollapsed); collapseIconEl.innerHTML=isChatModuleCollapsed?'üí¨':'‚úñÔ∏è'; collapseIconEl.title=isChatModuleCollapsed?'Open':'Close'; }
        function toggleFullFrame(){ if(!chatModuleWrapper||!fullFrameToggleIconEl){logError("toggleFullFrame: Missing wrapper or icon"); return;} logInfo('Toggling full frame mode'); isFullFrame=!isFullFrame; chatModuleWrapper.classList.toggle('full-frame-mode',isFullFrame); fullFrameToggleIconEl.innerHTML=isFullFrame?'‚ÜôÔ∏è':'‚ÜóÔ∏è'; fullFrameToggleIconEl.title=isFullFrame?'Exit Full':'Enter Full'; localStorage.setItem(LOCAL_STORAGE_KEYS.IS_FULL_FRAME,isFullFrame); if(isFullFrame&&isChatModuleCollapsed)chatModuleContainerEl.classList.remove('collapsed'); if(collapseIconEl)collapseIconEl.style.display=isFullFrame?'none':'inline-flex'; }
        function toggleSetupSection(){ if(!setupSectionEl||!setupSectionTitleEl){logError("toggleSetupSection: Missing section or title"); return;} logInfo('Toggling setup section'); setupSectionEl.classList.toggle('collapsed'); isSetupSectionCollapsed=setupSectionEl.classList.contains('collapsed'); localStorage.setItem(LOCAL_STORAGE_KEYS.IS_SETUP_COLLAPSED,isSetupSectionCollapsed); const arrow=setupSectionTitleEl.querySelector('span'); if(arrow)arrow.innerHTML=isSetupSectionCollapsed?'‚ñ∂Ô∏è':'üîΩ'; }
        function showClearModal(){logInfo('Showing clear modal'); if(clearStorageModalEl)clearStorageModalEl.style.display='flex'; else { logError("clearStorageModalEl not found"); }}
        function hideClearModal(){logInfo('Hiding clear modal'); if(clearStorageModalEl)clearStorageModalEl.style.display='none';}
        function confirmClear(){logWarn('Clearing local storage and reloading!'); Object.values(LOCAL_STORAGE_KEYS).forEach(k=>localStorage.removeItem(k)); hideClearModal(); addSystemMessage('Data cleared. Reloading...'); setTimeout(()=>window.location.reload(),1500);}
        function setLocalDisplayName(nameIn){const n=nameIn.trim(); const oldN=myDisplayName; if(n&&n.length>0&&n.length<=DISPLAY_NAME_MAX_LENGTH){logInfo('Setting display name locally:', n); myDisplayName=n; localStorage.setItem(LOCAL_STORAGE_KEYS.DISPLAY_NAME,myDisplayName); addSystemMessage(`Name set to "${sanitizeHTML(myDisplayName)}"`); if(setDisplayNameBtnEl)setDisplayNameBtnEl.textContent="Update"; updateChatLogDisplayName(myPeerId,myDisplayName); return true;}else if(!n){logInfo('Clearing display name'); const oN=myDisplayName; myDisplayName=null; localStorage.removeItem(LOCAL_STORAGE_KEYS.DISPLAY_NAME); addSystemMessage(`Name cleared (was "${sanitizeHTML(oN||'')}").`); if(displayNameInputEl)displayNameInputEl.value=""; if(setDisplayNameBtnEl)setDisplayNameBtnEl.textContent="Set Name"; updateChatLogDisplayName(myPeerId,null); return true;}else{addSystemMessage(`Invalid name (max ${DISPLAY_NAME_MAX_LENGTH}).`);return false;}}
        function propagateDisplayNameChange(){if(peer&&peer.open&&myPeerId&¬§tPeerConnection&¬§tPeerConnection.open){logInfo('Propagating name change:',myDisplayName); const nUpdMsg={type:'name-update',peerId:myPeerId,newName:myDisplayName}; sendEncoded(currentPeerConnection,nUpdMsg);}else{logWarn('Cannot propagate name, peer/conn not ready.');}}

        // --- PEERJS & CHAT ---
        function updateSelfStatusDisplay() {
            let statusText = "üö¶ Ready. Set name. Click 'Ready to Host' or 'Connect'.";
            let showId = false; let copyEnabled = false; let sendEnabled = false;
            let hostEnabled = true; let connectEnabled = true; let inputEnabled = true;

            try { // Wrap in try-catch for safety during updates
                if(peer && peer.open && myPeerId) {
                    showId = true; copyEnabled = true;
                    const nameDisp = sanitizeHTML(myDisplayName || getShortPeerId(myPeerId));
                    if(isReadyToHost) {
                        statusText = `üëÇ Hosting. Share Your ID: ${getShortPeerId(myPeerId)}`;
                        hostEnabled = false; connectEnabled = false; inputEnabled = false;
                        sendEnabled = currentPeerConnection && currentPeerConnection.open;
                        if(currentPeerConnection && currentPeerConnection.open){
                            const remoteName = sanitizeHTML(currentPeerConnection.metadata?.name || getShortPeerId(currentPeerConnection.peer));
                            statusText = `üëÇ Hosting ID ${getShortPeerId(myPeerId)}. Connected to ${remoteName}.`;
                        }
                    } else if (currentPeerConnection && currentPeerConnection.open) {
                        const remoteName = sanitizeHTML(currentPeerConnection.metadata?.name || getShortPeerId(currentPeerConnection.peer));
                        statusText = `‚úÖ Connected to ${remoteName} as ${nameDisp}.`;
                        hostEnabled = false; connectEnabled = false; inputEnabled = false;
                        sendEnabled = true;
                    } else { // Peer online, but idle
                        statusText = `üì∂ Online as ${nameDisp}. Click Host or enter Peer ID & Connect.`;
                    }
                } else if (peerInitAttempts > 0 && peerInitAttempts <= MAX_PEER_INIT_ATTEMPTS) {
                     statusText = `‚è≥ Connecting PeerJS attempt ${peerInitAttempts}/${MAX_PEER_INIT_ATTEMPTS}...`;
                     hostEnabled = false; connectEnabled = false; inputEnabled = false;
                } else if (peerInitAttempts > MAX_PEER_INIT_ATTEMPTS) {
                    if (peerJsServerErrorCount >= MAX_CONSECUTIVE_SERVER_ERRORS) statusText = `‚ùå Server issue. Check network & Retry.`;
                    else statusText = `‚ùå PeerJS failed. Retry.`;
                }

                updateStatusUI(statusText);
                if(peerIdDisplayAreaEl) peerIdDisplayAreaEl.style.display = showId ? 'block' : 'none';
                if(myPeerIdValueEl && showId) myPeerIdValueEl.textContent = myPeerId;
                if(copyMyIdBtnEl) copyMyIdBtnEl.disabled = !copyEnabled;
                if(sendBtnEl) sendBtnEl.disabled = !sendEnabled;
                if(messageInputEl) messageInputEl.disabled = !sendEnabled;
                if(hostBtnEl) hostBtnEl.disabled = !hostEnabled;
                if(connectBtnEl) connectBtnEl.disabled = !connectEnabled;
                if(hostIdInputEl) hostIdInputEl.disabled = !inputEnabled;

            } catch (error) {
                logError("Error during updateSelfStatusDisplay:", error);
                updateStatusUI("‚ö†Ô∏è Error updating status.");
            }
        }
        function addSystemMessage(text){logInfo('System Msg:', text); addMessage(text,'system',null);}
        function addChatMessage(text,senderId,senderName){logInfo(`Chat Msg From ${getShortPeerId(senderId)} (${senderName||''}): ${text}`); addMessage(text,senderId,senderName);}
        function addMessage(text, senderId, senderNameFromNetwork) {
             if(!chatEl) { logError("chatEl not found in addMessage"); return; }
             try {
                 const div = document.createElement('div'); div.className = 'message-item';
                 const sanitizedText = sanitizeHTML(text);
                 if(senderId && senderId !== 'system') { div.dataset.peerId = senderId; }
                 if(senderId === 'system') { div.innerHTML = `<em>${sanitizedText}</em>`; div.classList.add('system-msg'); }
                 else { let nameSpanHTML = ''; let finalDisplayLabel; let currentSenderNameToUse = senderNameFromNetwork;
                      if (senderId === myPeerId) { currentSenderNameToUse = myDisplayName; }
                      else if (currentPeerConnection && senderId === currentPeerConnection.peer) { currentSenderNameToUse = currentPeerConnection.metadata?.name || senderNameFromNetwork; }
                      const nameBase = sanitizeHTML(currentSenderNameToUse || getShortPeerId(senderId));
                      if(senderId === myPeerId) { finalDisplayLabel = `${nameBase} (You)`; nameSpanHTML = `<span class="sender-tag you">${finalDisplayLabel}:</span> `; div.classList.add('local'); }
                      else { finalDisplayLabel = nameBase; nameSpanHTML = `<span class="sender-tag peer">${finalDisplayLabel}:</span> `; div.classList.add('remote'); }
                      div.innerHTML = nameSpanHTML + sanitizedText;
                  }
                 const shouldScroll = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 30;
                 chatEl.appendChild(div);
                 if(shouldScroll || senderId === myPeerId) chatEl.scrollTop = chatEl.scrollHeight;
            } catch (error) {
                logError("Error adding message to chat:", error, {text: text, senderId: senderId});
            }
        }
        function updateChatLogDisplayName(peerIdToUpdate, newDisplayName) {
             if(!chatEl || !peerIdToUpdate) return;
             try {
                 const messages = chatEl.querySelectorAll(`.message-item[data-peer-id="${peerIdToUpdate}"]`);
                 logInfo(`Updating display name in chat log for ${getShortPeerId(peerIdToUpdate)} to "${newDisplayName||'(use ID)'}" (${messages.length} msgs)`);
                 messages.forEach(msgEl => {
                     const tag = msgEl.querySelector('.sender-tag'); if(!tag) return;
                     let label; const isLocal = peerIdToUpdate === myPeerId;
                     const nameBase = sanitizeHTML(newDisplayName || getShortPeerId(peerIdToUpdate));
                     if(isLocal) label = `${nameBase} (You)`; else label = nameBase;
                     tag.innerHTML = `${label}:`;
                 });
            } catch (error) {
                logError("Error updating chat log display names:", error);
            }
        }

        // --- PEERJS CORE ---
        function initializePeer() {
            if(peer && !peer.destroyed){ logWarn("Destroying existing peer before init."); peer.destroy(); }
            peer = null; peerInitAttempts++;
            logInfo(`Init PJS Attempt ${peerInitAttempts}.`);

            if(peerInitAttempts > MAX_PEER_INIT_ATTEMPTS || peerJsServerErrorCount >= MAX_CONSECUTIVE_SERVER_ERRORS) { logError(`Max init attempts or server errors reached.`); updateStatusUI("‚ùå PeerJS failed. Try again manually."); if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false; updateSelfStatusDisplay(); return; }

            let idToTry = localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID) || DEFAULT_PEER_ID_PREFIX + Math.random().toString(36).substr(2, 9);
            logInfo(`Attempting PJS connection with ID: ${idToTry}`);
            updateStatusUI(`‚è≥ Connecting PeerJS (Attempt ${peerInitAttempts})...`);

            // *** PASTE YOUR VALID TURN SERVER CONFIGURATION HERE ***
            const iceServers = [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                // --- FOR INTERNET CONNECTIONS, UNCOMMENT AND FILL THESE ---
                 // {
                 //     urls: 'turn:YOUR_TURN_SERVER_ADDRESS:3478', // e.g., turn:numb.viagenie.ca:3478
                 //     username: 'YOUR_TURN_USERNAME',           // e.g., your_email@example.com
                 //     credential: 'YOUR_TURN_PASSWORD'          // e.g., the password provided
                 // },
                 // {
                 //     urls: 'turn:YOUR_TURN_SERVER_ADDRESS:3478?transport=udp',
                 //     username: 'YOUR_TURN_USERNAME',
                 //     credential: 'YOUR_TURN_PASSWORD'
                 // },
                 // {
                 //     urls: 'turn:YOUR_TURN_SERVER_ADDRESS:3478?transport=tcp',
                 //     username: 'YOUR_TURN_USERNAME',
                 //     credential: 'YOUR_TURN_PASSWORD'
                 // }
                 // ---------------------------------------------------------
            ];
            // ***********************************************************

            try { peer = new Peer(idToTry, { config: { iceServers: iceServers }, debug: 2 }); }
            catch(e) { logError(`Peer INSTANTIATION error: ${e}`, e); peerJsServerErrorCount++; updateStatusUI("‚ùå Error creating Peer object."); schedulePeerReinit(true); return; }

            peer.on('open', id => { logInfo(`‚úÖ PeerJS OPEN. ID: ${id}`); myPeerId = id; peerInitAttempts = 0; peerJsServerErrorCount = 0; localStorage.setItem(LOCAL_STORAGE_KEYS.PEER_ID, id); addSystemMessage(`üì∂ Online. Your ID: ${getShortPeerId(id)}`); updateSelfStatusDisplay(); processMessageQueue(); });
            peer.on('connection', setupIncomingConnObj);
            peer.on('error', err => { logError(`üí• Peer Error: ${err.type}. Attempt ID: ${idToTry}. Msg: ${err.message||'(none)'}`, err); let schedRe=false; let forceN=false; let statMsg=`‚ùå Error: ${err.type}.`; const servErrs=['network','server-error','socket-error','socket-closed','disconnected']; if(servErrs.includes(err.type)){peerJsServerErrorCount++;logWarn(`Consecutive server errors: ${peerJsServerErrorCount}/${MAX_CONSECUTIVE_SERVER_ERRORS}`); if(peerJsServerErrorCount<MAX_CONSECUTIVE_SERVER_ERRORS){schedRe=true; statMsg+=" Retrying signal server...";}else{statMsg=`‚ùå Persistent Server Conn issue (${err.type}). Check network. Try again manually.`; peerInitAttempts=MAX_PEER_INIT_ATTEMPTS+1; if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false;}} else if(err.type==='unavailable-id'){peerJsServerErrorCount=0; statMsg=`‚ùå ID ${getShortPeerId(idToTry)} unavailable. Trying different ID...`; forceN=true; schedRe=true;} else if(err.type==='peer-unavailable'){peerJsServerErrorCount=0; const tgt=err.message?err.message.split(' ').pop():'peer'; statMsg=`‚ùå Could not connect to ${getShortPeerId(tgt)}. Offline/unreachable.`; addSystemMessage(statMsg); if(connectBtnEl)connectBtnEl.disabled=false; if(hostBtnEl&&!isReadyToHost)hostBtnEl.disabled=false;} else {peerJsServerErrorCount=0; statMsg=`‚ùå PeerJS Error (${err.type}). Try again manually.`; if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false;} updateStatusUI(statMsg); if(schedRe)schedulePeerReinit(forceN); updateSelfStatusDisplay(); });
            peer.on('disconnected',()=>{logWarn('[P2P] Disconnected from PeerJS Server.'); updateStatusUI("‚è≥ Disconnected. Reconnecting..."); peerJsServerErrorCount++; if(peerJsServerErrorCount<MAX_CONSECUTIVE_SERVER_ERRORS){schedulePeerReinit(false);}else{updateStatusUI("‚ùå Persistent disconnect. Check network. Try again."); peerInitAttempts=MAX_PEER_INIT_ATTEMPTS+1; if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false; updateSelfStatusDisplay();}});
            peer.on('close',()=>{logWarn('[P2P] Peer closed.'); updateStatusUI("üö¶ Connection closed. Host/Connect again."); myPeerId=null; peer=null; isReadyToHost=false; peerInitAttempts=0; peerJsServerErrorCount=0; resetConnectionState(); updateSelfStatusDisplay();});
        }
        function schedulePeerReinit(forceNewId){ if(peer&&!peer.destroyed)peer.destroy();peer=null; if(peerInitAttempts>MAX_PEER_INIT_ATTEMPTS||peerJsServerErrorCount>=MAX_CONSECUTIVE_SERVER_ERRORS){logWarn("Skipping scheduled re-init: Max attempts/errors."); updateStatusUI("‚ùå Failed PeerJS init. Try again."); if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false; updateSelfStatusDisplay(); return;} const d=Math.min(4000+(peerInitAttempts*2000),20000); logInfo(`Scheduling re-init in ${d/1000}s. ForceNew:${forceNewId}, Atmpt:${peerInitAttempts+1}, SrvErrs:${peerJsServerErrorCount}`); updateStatusUI(`‚è≥ Connection failed. Retrying in ${Math.round(d/1000)}s...`); setTimeout(()=>{if(!peer){initializePeer();}else{logInfo("Skipping scheduled re-init, peer exists.");}},d);}
        function sendEncoded(c,dObj){if(c&&c.open){try{c.send(textEncoder.encode(JSON.stringify(dObj)));logInfo('Sent Encoded:', dObj, 'to', getShortPeerId(c.peer));}catch(e){logError('SendEnc Err:',e);}}else{logWarn('SendEnc on closed/null conn:', c?getShortPeerId(c.peer):'N/A');}}

        function setupIncomingConnObj(conn) {
            if (!isReadyToHost) { logWarn("Incoming connection ignored, not ready to host."); conn.close(); return; }
            if (currentPeerConnection) { logWarn(`Already connected to ${getShortPeerId(currentPeerConnection.peer)}. Rejecting incoming from ${getShortPeerId(conn.peer)}.`); conn.close(); return; }

            const connId = conn.peer; conn.metadata = conn.metadata || {}; conn.displayName = conn.metadata.name || null;
            currentPeerConnection = conn; // Store as the main connection
            logInfo(`Incoming Conn Accepted: ${getShortPeerId(connId)} (${conn.displayName || 'No Name'})`);

            conn.on('open', () => {
                 const remoteName = sanitizeHTML(conn.displayName || getShortPeerId(connId));
                 addSystemMessage(`${remoteName} connected to you.`);
                 updateSelfStatusDisplay();
                 sendEncoded(conn, { type: 'name-update', peerId: myPeerId, newName: myDisplayName });
                 processMessageQueue();
            });
            conn.on('data', data => { try { handleIncomingData(JSON.parse(textDecoder.decode(data)), connId, conn); } catch(e){ logError('Data Err (Inc):', e); }});
            conn.on('close', () => { addSystemMessage(`${sanitizeHTML(conn.displayName||getShortPeerId(connId))} disconnected.`); logWarn(`Conn closed (Inc): ${getShortPeerId(connId)}`); if(currentPeerConnection && currentPeerConnection.peer === connId) resetConnectionState(); updateSelfStatusDisplay(); });
            conn.on('error', err => { logError(`ConnErr (Inc) ${getShortPeerId(connId)}:${err.type}`); if(currentPeerConnection && currentPeerConnection.peer === connId) resetConnectionState(); updateSelfStatusDisplay(); });
        }

        function setupOutgoingConnObj(conn) {
             const connId = conn.peer; conn.metadata = conn.metadata || {}; conn.displayName = conn.metadata.name || null;
             currentPeerConnection = conn;
             logInfo(`Outgoing Conn Init: ${getShortPeerId(connId)}`);

             conn.on('open', () => {
                 const remoteName = sanitizeHTML(conn.displayName || getShortPeerId(connId)); // Might get updated later
                 addSystemMessage(`‚úÖ Connection to ${remoteName} established.`);
                 // Update buttons *after* successful open
                 if(connectBtnEl) connectBtnEl.disabled = true; if(hostBtnEl) hostBtnEl.disabled = true;
                 if(hostIdInputEl) hostIdInputEl.disabled = true;
                 updateSelfStatusDisplay();
                 sendEncoded(conn, { type: 'name-update', peerId: myPeerId, newName: myDisplayName });
                 processMessageQueue();
             });
             conn.on('data', data => { try { const d=JSON.parse(textDecoder.decode(data));logInfo('Received Data:',d,'from',getShortPeerId(connId));handleIncomingData(d,connId,conn); } catch(e){ logError('Data Err (Out):', e); }});
             conn.on('close', () => { addSystemMessage(`Disconnected from ${sanitizeHTML(conn.displayName||getShortPeerId(connId))}.`); logWarn(`Conn closed (Out): ${getShortPeerId(connId)}`); resetConnectionState(); updateSelfStatusDisplay(); });
             // Handle connection errors for outgoing attempts
             conn.on('error', err => {
                 logError(`ConnErr (Out) ${getShortPeerId(connId)}:${err.type}`);
                 addSystemMessage(`‚ùå Error connecting to ${getShortPeerId(connId)}: ${err.type}`);
                 resetConnectionState();
                 // Re-enable buttons since the connection failed
                 if(hostBtnEl) hostBtnEl.disabled = false; if(connectBtnEl) connectBtnEl.disabled = false; if(hostIdInputEl) hostIdInputEl.disabled = false;
                 updateSelfStatusDisplay();
             });
        }

        function handleIncomingData(dObj, fromId, cInst){
            logInfo('Handling Data:', dObj, 'from', getShortPeerId(fromId));
            if (!currentPeerConnection || currentPeerConnection.peer !== fromId) {
                logWarn("Ignoring data from non-current peer:", getShortPeerId(fromId));
                return; // Ignore data if not from the main connection
            }
            // Update name in metadata if received
            if(dObj.type === 'name-update' && cInst) {
                 const oldName = sanitizeHTML(cInst.displayName || getShortPeerId(fromId));
                 cInst.displayName = dObj.newName;
                 cInst.metadata = {...cInst.metadata, name: dObj.newName }; // Update metadata too
                 updateChatLogDisplayName(fromId, dObj.newName);
                 addSystemMessage(`${oldName} is now ${sanitizeHTML(dObj.newName || getShortPeerId(fromId))}.`);
            } else if (dObj.type === 'chat-message') {
                 const senderName = cInst.displayName || dObj.sName || getShortPeerId(fromId); // Use stored name first
                 addChatMessage(dObj.text, fromId, senderName);
            } else { logWarn("Received unknown data type:", dObj.type); }
            updateSelfStatusDisplay();
        }

        function processMessageQueue(){ if(!peer||peer.destroyed||!peer.open){if(messageQueue.length>0)logInfo(`Peer not ready, ${messageQueue.length} msgs queued.`);return;} const tQ=[...messageQueue];messageQueue=[]; tQ.forEach(i=>{let snt=false;if(i.target==='peer'&¬§tPeerConnection&¬§tPeerConnection.open){sendToPeer(i.text,true);snt=true;} if(!snt)messageQueue.push(i);}); if(messageQueue.length>0)logWarn(`${messageQueue.length} msgs re-queued.`);}

        function sendToPeer(txt, fQ=false){
            logInfo('Attempting sendToPeer:', txt);
            if(!currentPeerConnection || !currentPeerConnection.open){ if(!fQ)messageQueue.push({text:txt,target:'peer'}); logWarn('Peer conn not ready, queue send'); addSystemMessage("Not connected. Message queued."); return;}
            addChatMessage(txt, myPeerId, myDisplayName||getShortPeerId(myPeerId)); // Show own message immediately
            sendEncoded(currentPeerConnection, {type:'chat-message', text:txt, sName:myDisplayName||getShortPeerId(myPeerId), peerId:myPeerId});
        }

        function propagateDisplayNameChange(){if(peer&&peer.open&&myPeerId&¬§tPeerConnection&¬§tPeerConnection.open){logInfo('Propagating name change:',myDisplayName); const nUpdMsg={type:'name-update',peerId:myPeerId,newName:myDisplayName}; sendEncoded(currentPeerConnection,nUpdMsg);}else{logWarn('Cannot propagate name, peer/conn not ready.');}}

        function resetConnectionState() {
             logWarn("Resetting connection state.");
             if (currentPeerConnection && !currentPeerConnection.destroyed) {
                 logInfo("Closing existing connection.");
                 currentPeerConnection.close();
             }
             currentPeerConnection = null;
             connections = {}; // Clear just in case
             isReadyToHost = false;
             messageQueue = [];
             // Let updateSelfStatusDisplay handle buttons
        }

        // --- EVENT LISTENERS ---
        function attachEventListeners(){
            logInfo("Attaching event listeners...");
            const safeAttach=(el,ev,hnd)=> {
                if (el) { el.addEventListener(ev,hnd); }
                else { logError(`Cannot attach ${ev}: Element not found for ID used.`); }
            };

            safeAttach(themeToggleIconEl,'click',()=>applyTheme(currentTheme==='dark'?'light':'dark'));
            safeAttach(collapseIconEl,'click',toggleChatModule);
            safeAttach(fullFrameToggleIconEl,'click',toggleFullFrame);
            safeAttach(clearStorageIconEl,'click',showClearModal);
            safeAttach(confirmClearBtnEl,'click',confirmClear);
            safeAttach(cancelClearBtnEl,'click',hideClearModal);
            if(clearStorageModalEl)safeAttach(window,'click',e=>{if(e.target===clearStorageModalEl)hideClearModal();});
            if(setupSectionTitleEl)safeAttach(setupSectionTitleEl,'click',toggleSetupSection);
            safeAttach(setDisplayNameBtnEl,'click',()=>{logInfo('Set Name Btn Click'); if(displayNameInputEl&&setLocalDisplayName(displayNameInputEl.value))propagateDisplayNameChange(); updateSelfStatusDisplay();});
            safeAttach(hostBtnEl,'click',handleHostButtonClick);
            safeAttach(connectBtnEl,'click',handleConnectButtonClick);

            const sendMessageHandler = () => {
                logInfo("Send Handler Triggered");
                if(!messageInputEl){logError("messageInputEl null"); return;}
                const txt=messageInputEl.value.trim(); if(!txt){logInfo("No text");return;}
                logInfo(`Attempt Send: text='${txt}', isHost=${isReadyToHost}, peer=${peer?.id}, open=${peer?.open}, currConn=${currentPeerConnection?.peer}, ccOpen=${currentPeerConnection?.open}`);
                // Send if connection is open
                if(currentPeerConnection && currentPeerConnection.open) sendToPeer(txt);
                else { messageQueue.push({text:txt, target:'peer'}); addSystemMessage("Not connected. Queued."); logWarn("Msg queued: No open conn.", messageQueue);}
                messageInputEl.value=''; messageInputEl.focus();
            };

            safeAttach(sendBtnEl,'click',sendMessageHandler);
            safeAttach(messageInputEl,'keypress',e=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();sendMessageHandler();}});
            safeAttach(copyMyIdBtnEl,'click',()=>{if(!myPeerId)return; navigator.clipboard.writeText(myPeerId).then(()=>{addSystemMessage('Full ID copied!');copyMyIdBtnEl.textContent='Copied!';setTimeout(()=>copyMyIdBtnEl.textContent='Copy',2000);}).catch(e=>{addSystemMessage('Copy failed.');logError('Clipboard copy failed:',e)});});
            logInfo("Event listeners attached.");
        }

        // --- HOST/CONNECT BUTTON HANDLERS ---
        function handleHostButtonClick() {
            logInfo('Ready to Host Btn Click');
            if (!peer || !peer.open) { addSystemMessage("‚ùå PeerJS not online yet. Wait or Retry."); initializePeer(); return; }
            isReadyToHost = true;
            resetConnectionState(); // Close any existing client connection
            addSystemMessage(`üëÇ Ready to host. Share Your ID (in Setup section).`);
            logInfo(`Hosting mode enabled. PeerID: ${myPeerId}`);
            updateSelfStatusDisplay(); // Update button states etc.
        }
        function handleConnectButtonClick() {
            logInfo('Connect Btn Click');
            isReadyToHost = false;
            if (!peer || !peer.open) { addSystemMessage("‚ùå PeerJS not online yet. Wait or Retry Connect."); initializePeer(); return; }
            if(!hostIdInputEl) { logError("hostIdInputEl not found"); return; }
            let remoteId = hostIdInputEl.value.trim();
            if (!remoteId) { addSystemMessage("‚ùå Please enter Peer ID to connect to."); return; }

            addSystemMessage(`üîó Connecting to ${getShortPeerId(remoteId)}...`);
            if(myPeerId && remoteId === myPeerId){ addSystemMessage("‚ùå Cannot connect to self."); return; }

            if(hostBtnEl) hostBtnEl.disabled=true; if(connectBtnEl) connectBtnEl.disabled=true; if(hostIdInputEl) hostIdInputEl.disabled=true; // Disable inputs during attempt

            const opts={reliable:true, serialization:'binary', metadata:{name:myDisplayName||getShortPeerId(myPeerId)}};
            resetConnectionState(); // Close any previous connection first
            logInfo(`Local peer ${myPeerId} attempting connect to ${remoteId}...`);
            const newConn = peer.connect(remoteId, opts);
            if (newConn) { setupOutgoingConnObj(newConn); } // Setup listeners
            else { logError("peer.connect() failed immediately."); addSystemMessage(`‚ùå Failed to initiate connection to ${getShortPeerId(remoteId)}.`); if(hostBtnEl)hostBtnEl.disabled=false; if(connectBtnEl)connectBtnEl.disabled=false; if(hostIdInputEl)hostIdInputEl.disabled=false; } // Re-enable if fails instantly
        }

        // --- INITIALIZATION ---
        function main(){
            logInfo("--- App Init Start ---");
            // Check essential elements BEFORE proceeding
            const essentialDOM = [chatModuleWrapper, chatModuleContainerEl, collapseIconEl, themeToggleIconEl, clearStorageIconEl, fullFrameToggleIconEl, statusEl, setupSectionEl, setupSectionTitleEl, peerIdDisplayAreaEl, myPeerIdValueEl, copyMyIdBtnEl, chatEl, messageInputAreaEl, messageInputEl, sendBtnEl, hostBtnEl, connectBtnEl, hostIdInputEl, displayNameInputEl, setDisplayNameBtnEl, clearStorageModalEl, confirmClearBtnEl, cancelClearBtnEl];
            if (essentialDOM.some(el => !el)) {
                 const missing = essentialDOM.filter(el => !el).map(el => { /* Find the variable name - tricky */ return 'Unknown Element'; }); // Improve this if needed
                 logError(`CRITICAL UI elements missing in main(). Missing: ${missing.join(', ')}. Aborting.`);
                 if(statusEl) statusEl.innerHTML = "‚ùå Fatal Error: UI elements missing.";
                 document.querySelectorAll('button, input').forEach(el => { if(el) el.disabled = true;});
                 return; // Stop initialization if critical UI is missing
            }

            myDisplayName=localStorage.getItem(LOCAL_STORAGE_KEYS.DISPLAY_NAME); displayNameInputEl.value=myDisplayName||""; setDisplayNameBtnEl.textContent=myDisplayName?"Update Name":"Set Name";
            currentTheme=localStorage.getItem(LOCAL_STORAGE_KEYS.THEME)||'dark'; applyTheme(currentTheme);
            isChatModuleCollapsed=false; // Default expanded
            collapseIconEl.innerHTML='‚úñÔ∏è'; chatModuleContainerEl.classList.remove('collapsed'); // Ensure starts expanded visually
            isFullFrame = localStorage.getItem(LOCAL_STORAGE_KEYS.IS_FULL_FRAME) === 'true';
            if(isFullFrame){ chatModuleWrapper.classList.add('full-frame-mode'); fullFrameToggleIconEl.innerHTML='‚ÜôÔ∏è'; if(collapseIconEl)collapseIconEl.style.display='none'; } else { fullFrameToggleIconEl.innerHTML='‚ÜóÔ∏è'; }
            isSetupSectionCollapsed = localStorage.getItem(LOCAL_STORAGE_KEYS.IS_SETUP_COLLAPSED) === 'true';
            if(isSetupSectionCollapsed){ setupSectionEl.classList.add('collapsed'); } const ar=setupSectionTitleEl.querySelector('span'); if(ar)ar.innerHTML=isSetupSectionCollapsed?'‚ñ∂Ô∏è':'üîΩ';
            hostIdInputEl.placeholder=`Enter Peer ID to Connect`;
            updateSelfStatusDisplay(); addSystemMessage(`üëã Welcome! PeerJS initializing...`);
            initializePeer();
            logInfo("--- App Init Complete ---");
        }

        // --- START ---
        logInfo("Script execution starting...");
        if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',()=>{logInfo("DOMContentLoaded event.");main();attachEventListeners();});} else{logInfo("DOM already ready.");main();attachEventListeners();}
        logInfo("Script execution finished.");

    </script>
</body>
</html>
