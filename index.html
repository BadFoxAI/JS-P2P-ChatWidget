
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat - ServerOne</title>
    <style>
        /* --- Theme Variables --- */
        :root {
            /* Default: Dark Theme */
            --chat-bg-body: #1a1a1a;
            --chat-bg-container: #2d2d2d;
            --chat-bg-input: #3c3c3c;
            --chat-bg-chat: #252525;
            --chat-bg-status-area: #333333; /* Renamed from chat-bg-status */
            --chat-bg-button-primary: #007acc;
            --chat-bg-button-primary-hover: #005fa3;
            --chat-bg-button-secondary: #505050;
            --chat-bg-button-secondary-hover: #606060;
            --chat-bg-button-disabled: #404040;
            --chat-text-primary: #e0e0e0;
            --chat-text-secondary: #b0b0b0;
            --chat-text-input: #f0f0f0;
            --chat-text-button: #ffffff;
            --chat-text-button-secondary: #e0e0e0;
            --chat-text-system: #9e9e9e;
            --chat-border-color: #4a4a4a;
            --chat-msg-bg-local: #004d7a;
            --chat-msg-bg-remote: #3e4042;
            --chat-icon-color: #b0b0b0;
            --chat-icon-hover-color: #ffffff;
            --chat-box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            --chat-modal-bg: rgba(0, 0, 0, 0.6);
            --chat-modal-content-bg: var(--chat-bg-container);
            --chat-section-bg: #292929; /* For control sections */
        }

        body.chat-light-theme { /* Light Theme Overrides */
            --chat-bg-body: #f4f6f8;
            --chat-bg-container: #ffffff;
            --chat-bg-input: #f0f0f0; /* Lightened input */
            --chat-bg-chat: #f5f5f5;
            --chat-bg-status-area: #e9ecef; /* Lightened status */
            --chat-bg-button-primary: #007bff;
            --chat-bg-button-primary-hover: #0056b3;
            --chat-bg-button-secondary: #6c757d;
            --chat-bg-button-secondary-hover: #545b62;
            --chat-bg-button-disabled: #cccccc;
            --chat-text-primary: #212529;
            --chat-text-secondary: #495057;
            --chat-text-input: #333333;
            --chat-text-button: #ffffff;
            --chat-text-button-secondary: #ffffff;
            --chat-text-system: #6c757d;
            --chat-border-color: #ced4da;
            --chat-msg-bg-local: #007bff;
            --chat-msg-bg-remote: #e9ecef;
            --chat-icon-color: #495057;
            --chat-icon-hover-color: #000000;
            --chat-box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            --chat-modal-bg: rgba(0, 0, 0, 0.4);
            --chat-modal-content-bg: var(--chat-bg-container);
            --chat-section-bg: #f8f9fa;
        }

        /* --- General Body Style --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--chat-bg-body);
            color: var(--chat-text-primary);
            margin: 0; padding: 0; font-size: 15px; line-height: 1.6;
            transition: background-color 0.2s ease-out, color 0.2s ease-out;
        }

        /* --- Chat Module Styles --- */
        #chatModuleWrapper { position: fixed; bottom: 20px; right: 20px; z-index: 1000; }
        #chatModuleContainer {
            width: 380px; max-height: calc(100vh - 90px); display: flex; flex-direction: column;
            background-color: var(--chat-bg-container); color: var(--chat-text-primary);
            border-radius: 10px; box-shadow: var(--chat-box-shadow);
            border: 1px solid var(--chat-border-color); overflow: hidden;
            transition: width 0.25s ease-out, height 0.25s ease-out, opacity 0.25s ease-out, transform 0.25s ease-out;
            transform-origin: bottom right;
        }
        #chatModuleContainer.collapsed {
            width: 48px; height: 48px; padding: 0; overflow: visible;
            border: none; background-color: transparent; box-shadow: none;
        }
        #chatModuleContainer.collapsed > *:not(#moduleToggleBar) { display: none !important; }

        #moduleToggleBar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; background-color: var(--chat-bg-status-area);
            border-bottom: 1px solid var(--chat-border-color); user-select: none; cursor: grab;
        }
        #chatModuleContainer.collapsed #moduleToggleBar {
            padding: 0; background-color: var(--chat-bg-button-secondary);
            width: 48px; height: 48px; border-radius: 50%;
            justify-content: center; align-items: center;
            border-bottom: none; box-shadow: var(--chat-box-shadow); cursor: pointer;
        }
        #chatModuleContainer.collapsed #moduleToggleBar #chatModuleTitle,
        #chatModuleContainer.collapsed #moduleToggleBar #themeToggleIcon,
        #chatModuleContainer.collapsed #moduleToggleBar #clearStorageIcon { display: none !important; }

        #chatModuleContainer.collapsed #moduleToggleBar #collapseIcon {
            display: inline-flex !important; align-items: center; justify-content: center;
            width: 100%; height: 100%; margin: 0; padding: 0;
            font-size: 22px; line-height: 1; border-radius: 0;
        }
        #chatModuleTitle { font-weight: 500; font-size: 1.05em; }
        .toggle-icon-group { display: flex; align-items: center; }
        #chatModuleContainer.collapsed #moduleToggleBar .toggle-icon-group {
            width: 100%; height: 100%; justify-content: center;
        }
        .toggle-icon {
            cursor: pointer; font-size: 20px; padding: 5px; margin-left: 6px; line-height: 1;
            color: var(--chat-icon-color); transition: color 0.2s ease, transform 0.15s ease;
            display: inline-flex; align-items: center; justify-content: center; border-radius: 4px;
        }
        .toggle-icon:hover { color: var(--chat-icon-hover-color); background-color: rgba(120,120,120,0.15);}
        .toggle-icon:active { transform: scale(0.9); }

        #chatModuleContent { padding: 12px; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

        /* --- Status Area --- */
        #statusArea { margin-bottom: 12px; padding: 8px; background-color: var(--chat-bg-status-area); border-radius: 6px; }
        #status { color: var(--chat-text-secondary); font-style: italic; text-align: center;
                  font-size: 0.9em; width: 100%; margin-bottom: 4px; }
        #peerIdDisplayArea { text-align: center; font-size: 0.85em; color: var(--chat-text-secondary); margin-top: 5px;}
        #myPeerIdValue { font-weight: bold; color: var(--chat-text-primary); user-select: all; }
        #copyMyIdBtn { /* Combined with status area */
            padding: 4px 8px; font-size: 0.8em; margin-left: 8px;
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
            border: none; border-radius: 4px; cursor: pointer;
        }
        #copyMyIdBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }

        /* --- Control Sections --- */
        .control-section {
            background-color: var(--chat-section-bg);
            padding: 12px; border-radius: 6px; margin-bottom: 12px;
            border: 1px solid var(--chat-border-color);
        }
        .section-title {
            font-size: 0.8em; text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--chat-text-secondary); margin: -12px -12px 10px -12px; padding: 6px 12px;
            border-bottom: 1px solid var(--chat-border-color); background-color: var(--chat-bg-status-area);
            border-top-left-radius: 6px; border-top-right-radius: 6px;
        }

        /* --- Name Input --- */
        .name-control-group { display: flex; gap: 8px; align-items: center; }
        #displayNameInput {
            flex-grow: 1; padding: 9px 12px; background-color: var(--chat-bg-input);
            color: var(--chat-text-input); border: 1px solid var(--chat-border-color);
            border-radius: 6px; font-size: 14px;
        }
        #displayNameInput::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}
        #setDisplayNameBtn {
             padding: 9px 12px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; transition: background-color 0.2s ease;
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
        }
        #setDisplayNameBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }

        /* --- Connection Controls --- */
        #hostBtn, #connectBtn {
            width: 100%; padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 500; transition: background-color 0.2s ease;
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
            margin-bottom: 8px;
        }
        #hostBtn:hover, #connectBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }

        #connectSection input[type="text"]#hostIdInput {
            width: 100%; box-sizing: border-box; padding: 9px 12px; background-color: var(--chat-bg-input);
            color: var(--chat-text-input); border: 1px solid var(--chat-border-color);
            border-radius: 6px; font-size: 14px; margin-bottom: 8px;
        }
        #connectSection input[type="text"]::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}

        /* --- General Buttons (Send) --- */
        #sendBtn {
            padding: 9px 15px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; transition: background-color 0.2s ease, color 0.2s ease;
            background-color: var(--chat-bg-button-primary); color: var(--chat-text-button);
        }
        #sendBtn:hover { background-color: var(--chat-bg-button-primary-hover); }

        /* --- Disabled State for all relevant buttons --- */
        #hostBtn:disabled, #connectBtn:disabled, #sendBtn:disabled, #setDisplayNameBtn:disabled, #copyMyIdBtn:disabled {
            background-color: var(--chat-bg-button-disabled) !important;
            color: #888 !important; cursor: not-allowed;
        }


        /* --- Chat Area --- */
        #chat { min-height:150px; height: 200px; background-color: var(--chat-bg-chat); border: 1px solid var(--chat-border-color);
                overflow-y: auto; margin-bottom: 12px; padding: 10px; border-radius: 6px; flex-grow: 1; }

        .message-item { margin-bottom: 8px; padding: 8px 12px; border-radius: 15px; max-width: 85%; word-wrap: break-word; }
        .message-item.local { background-color: var(--chat-msg-bg-local); color: #e1f5fe; margin-left: auto; border-bottom-right-radius: 5px; text-align: left; }
        body.chat-light-theme .message-item.local { color: var(--chat-text-button); }
        .message-item.remote { background-color: var(--chat-msg-bg-remote); color: var(--chat-text-primary); margin-right: auto; border-bottom-left-radius: 5px; }
        body.chat-light-theme .message-item.remote { color: var(--chat-text-input); }
        .message-item .sender-tag { font-weight: 600; margin-right: 5px; display: inline-block; font-size: 0.9em; }
        .message-item .sender-tag.host { color: #c59eff; } body.chat-light-theme .message-item .sender-tag.host { color: #8a2be2;}
        .message-item .sender-tag.you { color: #90caf9; } body.chat-light-theme .message-item .sender-tag.you { color: var(--chat-bg-button-primary);}
        .message-item .sender-tag.peer { color: #aaaaaa; } body.chat-light-theme .message-item .sender-tag.peer { color: #555555;}
        .message-item.system-msg { background-color: transparent; color: var(--chat-text-system); font-style: italic; font-size: 0.85em; text-align: center; max-width: 100%; padding: 4px 0; }

        #messageInput { width: calc(100% - 80px); background-color: var(--chat-bg-input); color: var(--chat-text-input);
                        border: 1px solid var(--chat-border-color); border-radius: 6px; font-size: 14px;
                        margin-right: 8px; padding: 9px 12px; }
        #messageInput::placeholder { color: var(--chat-text-secondary); opacity: 0.7;}

        /* --- Modal Styles --- */
        .modal-overlay {
            display: none; position: fixed; z-index: 2000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: var(--chat-modal-bg);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--chat-modal-content-bg);
            margin: auto; padding: 20px;
            border: 1px solid var(--chat-border-color); border-radius: 8px;
            width: 80%; max-width: 320px; box-shadow: var(--chat-box-shadow);
            text-align: center; color: var(--chat-text-primary);
        }
        .modal-content p { margin-bottom: 20px; font-size: 1.05em; }
        .modal-buttons button {
            padding: 10px 18px; margin: 0 10px;
            border: none; border-radius: 6px; cursor: pointer; font-size: 14px;
            transition: background-color 0.2s ease;
        }
        .modal-buttons button#confirmClearBtn {
            background-color: var(--chat-bg-button-primary); color: var(--chat-text-button);
        }
        .modal-buttons button#confirmClearBtn:hover { background-color: var(--chat-bg-button-primary-hover); }
        .modal-buttons button#cancelClearBtn {
            background-color: var(--chat-bg-button-secondary); color: var(--chat-text-button-secondary);
        }
        .modal-buttons button#cancelClearBtn:hover { background-color: var(--chat-bg-button-secondary-hover); }
    </style>
</head>
<body>
    <div id="chatModuleWrapper">
        <div id="chatModuleContainer">
            <div id="moduleToggleBar">
                <span id="chatModuleTitle">P2P Chat</span>
                <div class="toggle-icon-group">
                    <span id="clearStorageIcon" class="toggle-icon" title="Clear Stored Data">üóëÔ∏è</span>
                    <span id="themeToggleIcon" class="toggle-icon" title="Toggle Theme">‚òÄÔ∏è</span>
                    <span id="collapseIcon" class="toggle-icon" title="Toggle Chat">üí¨</span>
                </div>
            </div>
            <div id="chatModuleContent">
                <div id="statusArea">
                    <div id="status" class="status">Initializing...</div>
                    <div id="peerIdDisplayArea" style="display: none;">
                        Your ID: <span id="myPeerIdValue"></span>
                        <button id="copyMyIdBtn">Copy</button>
                    </div>
                </div>

                <div class="control-section">
                    <p class="section-title">Display Name</p>
                    <div class="name-control-group">
                        <input type="text" id="displayNameInput" placeholder="Your Name (max 30 chars)">
                        <button id="setDisplayNameBtn">Set Name</button>
                    </div>
                </div>

                <div class="control-section">
                    <p class="section-title">Connection</p>
                    <button id="hostBtn">Become Host</button>
                    <div id="connectSection">
                        <input type="text" id="hostIdInput" placeholder="Peer ID (or blank for ServerOne)">
                        <button id="connectBtn">Connect to Peer</button>
                    </div>
                </div>

                <div id="chat"></div>
                <div style="display: flex; margin-top: auto;"> <!-- Chat input area -->
                    <input type="text" id="messageInput" placeholder="Type message...">
                    <button id="sendBtn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="clearStorageModal" class="modal-overlay">
        <div class="modal-content">
            <p>Are you sure you want to clear all stored chat data (theme, name, PeerID)?</p>
            <div class="modal-buttons">
                <button id="confirmClearBtn">Yes, Clear Data</button>
                <button id="cancelClearBtn">No, Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // --- Application Constants ---
        const MAX_PEER_INIT_ATTEMPTS = 5;
        const DEFAULT_PEER_ID_PREFIX = 'peerjs-chat-'; // Changed prefix slightly
        const SHORT_ID_LENGTH = 7;
        const DISPLAY_NAME_MAX_LENGTH = 30;
        const LOCAL_STORAGE_KEYS = {
            THEME: 'chatAppTheme_v2',
            DISPLAY_NAME: 'chatUserDisplayName_v2',
            PEER_ID: 'chatAppPeerId_v2'
        };
        const SERVER_ONE_PEER_ID = 'p2p-chat-rendezvous-serverone-20231220'; // Ensure unique

        // --- Application State Variables ---
        let peer;
        let hostConnection; // Client's connection to the host
        let connections = {}; // Host's connections to clients
        let isHost = false; // User's *intent* to be a host
        let messageQueue = [];
        let myPeerId = null; // Actual PeerID from PeerJS server
        let myDisplayName = null;
        let peerInitAttempts = 0;
        let isChatModuleCollapsed = false;
        let currentTheme = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME) || 'dark';
        let isActingAsServerOne = false;
        let currentConnectionTargetIsServerOne = false; // For connect logic

        // --- DOM Element References ---
        const chatModuleContainerEl = document.getElementById('chatModuleContainer');
        const collapseIconEl = document.getElementById('collapseIcon');
        const themeToggleIconEl = document.getElementById('themeToggleIcon');
        const clearStorageIconEl = document.getElementById('clearStorageIcon');
        const statusEl = document.getElementById('status');
        const peerIdDisplayAreaEl = document.getElementById('peerIdDisplayArea');
        const myPeerIdValueEl = document.getElementById('myPeerIdValue');
        const copyMyIdBtnEl = document.getElementById('copyMyIdBtn');
        const chatEl = document.getElementById('chat');
        const messageInputEl = document.getElementById('messageInput');
        const sendBtnEl = document.getElementById('sendBtn');
        const hostBtnEl = document.getElementById('hostBtn');
        const connectBtnEl = document.getElementById('connectBtn');
        const hostIdInputEl = document.getElementById('hostIdInput');
        const displayNameInputEl = document.getElementById('displayNameInput');
        const setDisplayNameBtnEl = document.getElementById('setDisplayNameBtn');
        const clearStorageModalEl = document.getElementById('clearStorageModal');
        const confirmClearBtnEl = document.getElementById('confirmClearBtn');
        const cancelClearBtnEl = document.getElementById('cancelClearBtn');

        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();

        // --- Utility Functions ---
        function sanitizeHTML(str) {
            if (typeof str !== 'string') return '';
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        function getShortPeerId(id) {
            if (!id) return 'unknown';
            if (id === SERVER_ONE_PEER_ID) return 'ServerOne';
            return id.slice(-SHORT_ID_LENGTH);
        }

        function updateSelfStatusDisplay() {
            let statusText = "Ready. Set name. Host or Connect.";
            peerIdDisplayAreaEl.style.display = 'none'; // Hide by default

            if (peer && peer.open && myPeerId) {
                const nameToDisplay = sanitizeHTML(myDisplayName || getShortPeerId(myPeerId));
                myPeerIdValueEl.textContent = getShortPeerId(myPeerId);
                peerIdDisplayAreaEl.style.display = 'block';
                copyMyIdBtnEl.disabled = false;

                if (isHost) {
                    statusText = `Hosting as ${isActingAsServerOne ? 'ServerOne' : nameToDisplay}.`;
                } else if (hostConnection && hostConnection.open) {
                    const hostDisplayName = sanitizeHTML(hostConnection.displayName || `Host (${getShortPeerId(hostConnection.peer)})`);
                    const connectedToLabel = hostConnection.peer === SERVER_ONE_PEER_ID ? 'ServerOne' : hostDisplayName;
                    statusText = `Connected to ${connectedToLabel} as ${nameToDisplay}.`;
                } else {
                    statusText = `Online as ${nameToDisplay}. Waiting to connect/host.`;
                }
            } else if (peerInitAttempts > 0 && peerInitAttempts <= MAX_PEER_INIT_ATTEMPTS) {
                 statusText = "Connecting to PeerJS network...";
            } else if (peerInitAttempts > MAX_PEER_INIT_ATTEMPTS) {
                statusText = "Failed to connect to PeerJS network. Try again.";
            }
            updateStatus(statusText);
        }

        // --- PeerJS Core Logic ---
        function initializePeer(requestedPeerIdForHostAttempt = null, isAttemptingServerOneRole = false) {
            if (peer && !peer.destroyed) {
                console.warn("[P2P CHAT] Active PeerJS instance found. Destroying old one.");
                peer.destroy();
            }
            peer = null; // Ensure old peer object is cleared

            peerInitAttempts++;
            console.info(`[P2P CHAT] Initializing PeerJS (Attempt ${peerInitAttempts}). For ServerOne Host: ${isAttemptingServerOneRole}, Requested ID: ${requestedPeerIdForHostAttempt || 'auto/stored'}`);

            if (MAX_PEER_INIT_ATTEMPTS > 0 && peerInitAttempts > MAX_PEER_INIT_ATTEMPTS) {
                console.error(`[P2P CHAT] Max PeerJS init attempts (${MAX_PEER_INIT_ATTEMPTS}) reached.`);
                updateStatus("Failed to connect to PeerJS network. Please try again manually.");
                hostBtnEl.disabled = false; connectBtnEl.disabled = false;
                updateSelfStatusDisplay();
                return;
            }

            let peerIdToUse;
            if (isAttemptingServerOneRole && isHost) { // Explicit attempt for ServerOne by host
                peerIdToUse = SERVER_ONE_PEER_ID;
            } else if (isHost && !isAttemptingServerOneRole) { // Host fallback (ServerOne was taken or not attempted) -> random
                peerIdToUse = DEFAULT_PEER_ID_PREFIX + Math.random().toString(36).substr(2, 9);
                console.info("[P2P CHAT] Host fallback or regular host: generating random ID:", peerIdToUse);
            } else { // Client initialization (always try stored first, then random)
                const storedId = localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID);
                if (storedId && storedId !== SERVER_ONE_PEER_ID) { // Don't reuse ServerOne for client unless explicitly connecting to it
                    peerIdToUse = storedId;
                } else {
                    peerIdToUse = DEFAULT_PEER_ID_PREFIX + Math.random().toString(36).substr(2, 9);
                }
            }

            console.info(`[P2P CHAT] Attempting PeerJS connection with ID: ${peerIdToUse}`);

            try {
                peer = new Peer(peerIdToUse, {
                    // key: 'your_peerjs_api_key', // If using PeerJS Cloud
                    // host: 'your_peerjs_server_host',
                    // port: your_peerjs_server_port,
                    // path: '/your_path'
                    config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] },
                    debug: 2
                });
            } catch (e) {
                console.error(`[P2P CHAT] Error creating PeerJS instance: ${e.message || e}`, e);
                updateStatus("Error initializing PeerJS. Retrying...");
                schedulePeerReinitialization(true, isHost && isAttemptingServerOneRole);
                return;
            }

            peer.on('open', (id) => {
                console.info(`[P2P CHAT] PeerJS OPENED. Actual ID: ${id}`);
                myPeerId = id;
                peerInitAttempts = 0; // Reset on success

                if (id !== SERVER_ONE_PEER_ID) { // Only store non-ServerOne IDs as general preference
                    localStorage.setItem(LOCAL_STORAGE_KEYS.PEER_ID, myPeerId);
                } else if (id === SERVER_ONE_PEER_ID && !isHost) {
                    // A client somehow got SERVER_ONE_PEER_ID - this is usually an error.
                    // PeerJS server should prevent this if another peer (the host) has it.
                    // If this client *is* the only one and got it, it's fine, but we don't store it as default.
                    console.warn("[P2P CHAT] Client initialized with SERVER_ONE_PEER_ID. This is unusual unless it's the only peer.");
                }


                if (isHost) {
                    isActingAsServerOne = (id === SERVER_ONE_PEER_ID && isAttemptingServerOneRole);
                    addMessage(`You are HOSTING ${isActingAsServerOne ? 'as ServerOne' : ''}. Your ID: ${getShortPeerId(myPeerId)}`, 'system');
                    hostBtnEl.disabled = true; connectBtnEl.disabled = true;
                } else { // Client is now online
                    hostBtnEl.disabled = false; connectBtnEl.disabled = false; // Ready to connect
                }
                updateSelfStatusDisplay();
                processMessageQueue();
            });

            peer.on('connection', (conn) => { setupConnectionObject(conn); });

            peer.on('error', (err) => {
                console.error(`[P2P CHAT] PeerJS Error: ${err.type} - ${err.message || err} (Attempted ID: ${peerIdToUse}, isHost: ${isHost}, isAttemptingS1: ${isAttemptingServerOneRole})`);
                let statusMessage = `Error: ${err.type}.`;
                let shouldRetry = false;
                let forceNewIdForRetry = false;
                let retryAsServerOneHost = isHost && isAttemptingServerOneRole; // Maintain intent if retrying

                if (err.type === 'unavailable-id') {
                    const unavailableId = peerIdToUse; // The ID that was actually tried
                    statusMessage = `ID ${getShortPeerId(unavailableId)} is unavailable.`;
                    if (localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID) === unavailableId) {
                        localStorage.removeItem(LOCAL_STORAGE_KEYS.PEER_ID);
                    }

                    if (isHost && isAttemptingServerOneRole && unavailableId === SERVER_ONE_PEER_ID) {
                        console.warn(`[P2P CHAT] SERVER_ONE_PEER_ID is unavailable. Falling back to regular host mode.`);
                        addMessage("ServerOne ID taken. Hosting with a random ID instead.", 'system');
                        if (peer && !peer.destroyed) peer.destroy(); peer = null; // Clean before immediate re-init
                        initializePeer(null, false); // Initialize as regular host (random ID, not ServerOne)
                        return; // Handled, exit this error handler
                    } else { // General unavailable ID or client init failed
                        forceNewIdForRetry = true; shouldRetry = true; retryAsServerOneHost = false;
                    }
                } else if (['network', 'server-error', 'socket-error', 'socket-closed'].includes(err.type)) {
                    statusMessage += " Retrying connection to signaling server."; shouldRetry = true;
                } else if (err.type === 'peer-unavailable') {
                    const failedTarget = err.message ? err.message.split(' ').pop() : 'unknown peer';
                    statusMessage = `Could not connect to ${getShortPeerId(failedTarget)}.`;
                    if (currentConnectionTargetIsServerOne && failedTarget.includes(SERVER_ONE_PEER_ID)) {
                         statusMessage = `Default rendezvous ServerOne (${getShortPeerId(SERVER_ONE_PEER_ID)}) is not available.`;
                    }
                    addMessage(statusMessage, 'system');
                    connectBtnEl.disabled = false; if (!isHost) hostBtnEl.disabled = false; // Re-enable buttons
                    // No automatic retry for 'peer-unavailable'
                } else if (err.type === 'disconnected') { // Disconnected from PeerJS signaling server
                    statusMessage = 'Disconnected from PeerJS server. Attempting to reconnect...';
                    shouldRetry = true;
                    retryAsServerOneHost = isHost && isActingAsServerOne; // Try to reclaim if was ServerOne
                } else { // Other errors
                    connectBtnEl.disabled = false; if (!isHost) hostBtnEl.disabled = false;
                }

                updateStatus(statusMessage);
                if (shouldRetry) {
                    schedulePeerReinitialization(forceNewIdForRetry, retryAsServerOneHost);
                }
                updateSelfStatusDisplay(); // Update display based on current state
            });

            peer.on('disconnected', () => {
                console.warn('[P2P CHAT] Disconnected from PeerJS server. Attempting to reconnect...');
                updateStatus('Disconnected. Reconnecting...');
                const retryAsS1 = isHost && isActingAsServerOne;
                schedulePeerReinitialization(false, retryAsS1);
            });

            peer.on('close', () => { // Peer object permanently closed
                console.warn('[P2P CHAT] PeerJS connection closed permanently.');
                updateStatus('Connection closed. Please Host or Connect again.');
                peer = null; myPeerId = null; isActingAsServerOne = false;
                hostBtnEl.disabled = false; connectBtnEl.disabled = false;
                peerInitAttempts = 0; // Reset for manual re-init
                updateSelfStatusDisplay();
            });
        }

        function schedulePeerReinitialization(forceNewId = false, retryServerOneHostAttempt = false) {
            if (peer && !peer.destroyed) { peer.destroy(); } peer = null; // Crucial: ensure old peer is gone

            const delay = Math.min(3000 + (peerInitAttempts * 1500), 15000);
            console.info(`[P2P CHAT] Scheduling PeerJS re-init in ${delay / 1000}s. ForceNewID: ${forceNewId}, RetryS1Host: ${retryServerOneHostAttempt}`);

            setTimeout(() => {
                // Determine which ID to request for the re-initialization attempt
                let idForNextAttempt = null;
                if (retryServerOneHostAttempt && isHost) { // Must still intend to be host
                    idForNextAttempt = SERVER_ONE_PEER_ID;
                } else if (!forceNewId) {
                    const stored = localStorage.getItem(LOCAL_STORAGE_KEYS.PEER_ID);
                    if (stored && stored !== SERVER_ONE_PEER_ID) idForNextAttempt = stored;
                }
                // Pass idForNextAttempt (which can be null for random) and ServerOne intent
                initializePeer(idForNextAttempt, retryServerOneHostAttempt);
            }, delay);
        }

        function sendEncoded(conn, dataObject) { /* ... (no change from previous valid version) ... */ }
        function setupConnectionObject(conn) { /* ... (no change from previous valid version, ensure displayName updates are handled) ... */
            const connId = conn.peer; conn.displayName = conn.metadata?.name || null;
            if (isHost) {
                connections[connId] = conn;
                console.info(`[P2P CHAT] Incoming connection from: ${getShortPeerId(connId)}${conn.displayName ? ` (${sanitizeHTML(conn.displayName)})` : ''}`);
            } else { // Client connected to a host
                hostConnection = conn;
                console.info(`[P2P CHAT] Connection established with host: ${getShortPeerId(connId)}${conn.displayName ? ` (${sanitizeHTML(conn.displayName)})` : ''}`);
            }

            conn.on('open', () => {
                const remoteIdentifier = sanitizeHTML(conn.displayName || getShortPeerId(connId));
                console.info(`[P2P CHAT] DataConnection to ${remoteIdentifier} (ID: ${getShortPeerId(connId)}) OPENED.`);
                addMessage(`${remoteIdentifier} connected.`, 'system');
                currentConnectionTargetIsServerOne = false; // Clear flag

                if (!isHost) { // Client successfully connected
                    connectBtnEl.disabled = true; hostBtnEl.disabled = true;
                }
                updateSelfStatusDisplay();

                if (isHost) {
                    sendEncoded(conn, { type: 'host-announcement', hostId: myPeerId, hostName: myDisplayName || getShortPeerId(myPeerId), isServerOne: isActingAsServerOne });
                    setTimeout(() => { // Send chat history if any
                        if (conn.open) {
                            sendEncoded(conn, {
                                type: 'chat-history',
                                messages: Array.from(chatEl.children)
                                    .filter(el => !el.classList.contains('system-msg') && el.dataset.peerId)
                                    .map(el => ({ html: el.innerHTML, className: el.className, peerId: el.dataset.peerId }))
                            });
                        }
                    }, 500);
                }
                processMessageQueue();
            });

            conn.on('data', (receivedData) => {
                try {
                    const jsonString = textDecoder.decode(receivedData);
                    const dataObject = JSON.parse(jsonString);
                    handleIncomingData(dataObject, connId, conn);
                } catch (error) { console.error(`[P2P CHAT] Error decoding/parsing: ${error}`, error); }
            });

            conn.on('close', () => {
                const remoteIdentifier = sanitizeHTML(conn.displayName || getShortPeerId(connId));
                console.warn(`[P2P CHAT] DataConnection to ${remoteIdentifier} CLOSED.`);
                addMessage(`${remoteIdentifier} disconnected.`, 'system');
                currentConnectionTargetIsServerOne = false;

                if (isHost) { delete connections[connId];
                } else if (hostConnection && hostConnection.peer === connId) {
                    hostConnection = null; hostIdInputEl.value = '';
                    connectBtnEl.disabled = false; if (!isHost) hostBtnEl.disabled = false;
                }
                updateSelfStatusDisplay();
            });
            conn.on('error', (err) => {
                console.error(`[P2P CHAT] DataConnection error with ${getShortPeerId(connId)}: ${err.type} - ${err.message || err}`);
                currentConnectionTargetIsServerOne = false;
            });
        }

        function handleIncomingData(dataObject, fromId, connectionInstance) { /* ... (no change from previous valid version, ensure host-announcement `isServerOne` is handled) ... */
            const senderIdentifier = dataObject.senderName || dataObject.name || (connectionInstance ? connectionInstance.displayName : null) || getShortPeerId(fromId);
            console.info(`[P2P CHAT] Decoded Data: type=${dataObject.type} from ${senderIdentifier} (ID: ${getShortPeerId(fromId)})`);
            switch (dataObject.type) {
                case 'chat-message':
                    addMessage(dataObject.text, fromId, dataObject.senderName);
                    if (isHost) { // Relay to other clients
                        Object.values(connections).forEach(c => {
                            if (c.peer !== fromId && c.open) { sendEncoded(c, dataObject); }
                        });
                    }
                    break;
                case 'name-update':
                    const oldSenderIdentifier = sanitizeHTML(connectionInstance?.displayName || getShortPeerId(dataObject.peerId));
                    if (isHost) {
                        if (connections[dataObject.peerId]) {
                            connections[dataObject.peerId].displayName = dataObject.newName;
                            Object.values(connections).forEach(clientConn => { // Relay to other clients
                                if (clientConn.peer !== dataObject.peerId && clientConn.open) { sendEncoded(clientConn, dataObject); }
                            });
                        }
                    } else { // Client receives update
                        if (hostConnection && hostConnection.peer === dataObject.peerId) { // Host updated their name
                            hostConnection.displayName = dataObject.newName;
                        }
                    }
                    updateChatLogDisplayName(dataObject.peerId, dataObject.newName);
                    updateSelfStatusDisplay();
                    addMessage(`${oldSenderIdentifier} is now known as ${sanitizeHTML(dataObject.newName || getShortPeerId(dataObject.peerId))}.`, 'system');
                    break;
                case 'host-announcement':
                    if (!isHost) { // Client receives this
                        const hostName = dataObject.hostName || getShortPeerId(dataObject.hostId);
                        if (connectionInstance) connectionInstance.displayName = dataObject.hostName; // Store host's name
                        addMessage(`Connected to host: ${sanitizeHTML(hostName)}`, 'system');
                        if (dataObject.isServerOne) {
                            addMessage(`This host is acting as ServerOne rendezvous.`, 'system');
                        }
                        updateSelfStatusDisplay();
                    }
                    break;
                case 'client-info': // Host receives this after a client connects if metadata wasn't enough
                    if (isHost && connectionInstance && dataObject.name) {
                        connectionInstance.displayName = dataObject.name;
                        addMessage(`${sanitizeHTML(dataObject.name)} (${getShortPeerId(fromId)}) updated their info.`, 'system');
                    }
                    break;
                case 'chat-history':
                    if (!isHost && dataObject.messages && Array.isArray(dataObject.messages)) {
                        chatEl.innerHTML = ''; // Clear existing messages before loading history
                        dataObject.messages.forEach(m => {
                            const div = document.createElement('div');
                            div.innerHTML = m.html; div.className = m.className;
                            if (m.peerId) div.dataset.peerId = m.peerId;
                            chatEl.appendChild(div);
                        });
                        chatEl.scrollTop = chatEl.scrollHeight; addMessage("Chat history loaded.", "system");
                    }
                    break;
                default: console.warn(`[P2P CHAT] Unknown data type: ${dataObject.type}.`);
            }
        }
        function processMessageQueue() { /* ... (no change from previous valid version) ... */ }
        function broadcastMessage(text) { /* ... (no change from previous valid version) ... */ }
        function sendToHost(text) { /* ... (no change from previous valid version) ... */ }

        // --- UI Interaction Functions ---
        function updateStatus(text) { statusEl.innerHTML = sanitizeHTML(text); }
        function addMessage(text, senderId, senderNameFromNetwork) { /* ... (no change from previous valid version) ... */ }
        function updateChatLogDisplayName(peerIdToUpdate, newDisplayName) { /* ... (no change from previous valid version) ... */ }
        function applyTheme(theme) { /* ... (no change from previous valid version) ... */ }
        function toggleChatModule() { /* ... (no change from previous valid version) ... */ }

        // --- Event Listeners ---
        setDisplayNameBtnEl.addEventListener('click', () => { /* ... (no change from previous valid version) ... */ });

        hostBtnEl.addEventListener('click', () => {
            console.info('[P2P CHAT] "Become Host" clicked.');
            isHost = true; isActingAsServerOne = false; currentConnectionTargetIsServerOne = false;
            hostBtnEl.disabled = true; connectBtnEl.disabled = true;
            peerIdDisplayAreaEl.style.display = 'none'; // Hide while (re)init
            if (peer && !peer.destroyed) { peer.destroy(); } peer = null;
            peerInitAttempts = 0;
            initializePeer(SERVER_ONE_PEER_ID, true); // Attempt ServerOne host role
        });

        connectBtnEl.addEventListener('click', () => {
            console.info('[P2P CHAT] "Connect to Peer" clicked.');
            isHost = false; isActingAsServerOne = false;
            hostBtnEl.disabled = true; connectBtnEl.disabled = true;
            peerIdDisplayAreaEl.style.display = 'none';

            let remoteHostId = hostIdInputEl.value.trim();
            currentConnectionTargetIsServerOne = !remoteHostId; // True if blank, trying ServerOne
            if (currentConnectionTargetIsServerOne) {
                remoteHostId = SERVER_ONE_PEER_ID;
                addMessage(`Attempting to connect to ServerOne (${getShortPeerId(SERVER_ONE_PEER_ID)})...`, 'system');
            } else {
                addMessage(`Attempting to connect to: ${getShortPeerId(remoteHostId)}...`, 'system');
            }

            if (myPeerId && remoteHostId === myPeerId) {
                addMessage("Cannot connect to self.", 'system');
                connectBtnEl.disabled = false; if (!isHost) hostBtnEl.disabled = false;
                return;
            }

            const connectOptions = { reliable: true, serialization: 'binary', metadata: { name: myDisplayName || getShortPeerId(myPeerId) } };

            if (!peer || peer.destroyed || !peer.open) { // Local peer not ready, initialize it first
                console.info("[P2P CHAT] Local PeerJS not ready, initializing for client connection.");
                if (peer && !peer.destroyed) { peer.destroy(); } peer = null;
                peerInitAttempts = 0;

                const onLocalPeerOpenForConnect = () => { // Closure for remoteHostId and connectOptions
                    if(peer) { peer.off('open', onLocalPeerOpenForConnect); } // Clean up listener
                    if (peer && peer.open && !peer.destroyed) {
                        console.info(`[P2P CHAT] Local PeerJS opened (ID: ${myPeerId}), now connecting to remote: ${remoteHostId}`);
                        hostConnection = peer.connect(remoteHostId, connectOptions);
                        setupConnectionObject(hostConnection);
                    } else {
                        console.error("[P2P CHAT] Local PeerJS failed to open for client connection attempt.");
                        addMessage("Connection failed: Local peer not ready.", "system");
                        connectBtnEl.disabled = false; if(!isHost) hostBtnEl.disabled = false;
                        currentConnectionTargetIsServerOne = false;
                    }
                };
                initializePeer(null, false); // Initialize local peer (random/stored ID, not ServerOne role)
                if (peer) { peer.on('open', onLocalPeerOpenForConnect); }
                else { /* Error in initializePeer already handled by its own logic */ }

            } else { // Local peer is ready
                console.info(`[P2P CHAT] Local PeerJS ready (ID: ${myPeerId}), connecting to remote: ${remoteHostId}`);
                hostConnection = peer.connect(remoteHostId, connectOptions);
                setupConnectionObject(hostConnection);
            }
        });

        function sendMessageHandler() { /* ... (no change from previous valid version) ... */ }
        sendBtnEl.addEventListener('click', sendMessageHandler);
        messageInputEl.addEventListener('keypress', (e) => { /* ... (no change from previous valid version) ... */ });
        collapseIconEl.addEventListener('click', toggleChatModule);
        themeToggleIconEl.addEventListener('click', () => { applyTheme(currentTheme === 'dark' ? 'light' : 'dark'); });
        clearStorageIconEl.addEventListener('click', () => { clearStorageModalEl.style.display = 'flex'; });
        confirmClearBtnEl.addEventListener('click', () => { /* ... (no change from previous valid version) ... */ });
        cancelClearBtnEl.addEventListener('click', () => { clearStorageModalEl.style.display = 'none'; });
        window.addEventListener('click', (event) => { if (event.target === clearStorageModalEl) clearStorageModalEl.style.display = 'none'; });

        copyMyIdBtnEl.addEventListener('click', () => {
            if (!myPeerId) { return; }
            navigator.clipboard.writeText(myPeerId).then(() => {
                addMessage('Your full PeerID copied to clipboard!', 'system');
                const originalText = copyMyIdBtnEl.textContent;
                copyMyIdBtnEl.textContent = 'Copied!';
                setTimeout(() => { copyMyIdBtnEl.textContent = originalText; }, 2000);
            }).catch(err => {
                console.error('[P2P CHAT] Failed to copy PeerID: ', err);
                addMessage('Could not auto-copy ID. Please select and copy manually.', 'system');
            });
        });

        // --- Initial Application Setup ---
        function main() {
            myDisplayName = localStorage.getItem(LOCAL_STORAGE_KEYS.DISPLAY_NAME);
            if (myDisplayName) {
                displayNameInputEl.value = myDisplayName;
                setDisplayNameBtnEl.textContent = "Update Name";
            } else { setDisplayNameBtnEl.textContent = "Set Name"; }

            currentTheme = localStorage.getItem(LOCAL_STORAGE_KEYS.THEME) || 'dark';
            applyTheme(currentTheme);

            hostIdInputEl.placeholder = `Peer ID (blank for ServerOne: ${getShortPeerId(SERVER_ONE_PEER_ID)})`;
            updateSelfStatusDisplay(); // Shows initial "Ready..." or "Connecting..."
            const welcomeName = myDisplayName ? `, ${sanitizeHTML(myDisplayName)}` : '';
            addMessage(`Welcome${welcomeName}! Set/confirm name, then Host or Connect.`, "system");

            collapseIconEl.innerHTML = '‚úñÔ∏è'; collapseIconEl.title = 'Close Chat';
            // Initially, user can host or connect
            hostBtnEl.disabled = false; connectBtnEl.disabled = false;
            sendBtnEl.disabled = true; // Can't send until connected/hosting
            copyMyIdBtnEl.disabled = true; // Can't copy until ID is known
        }

        main();
    </script>
</body>
</html>
